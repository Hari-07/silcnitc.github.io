<!DOCTYPE html>
<html lang="en">
<head>
<title>LEX</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="css/style.css">
<!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body>
<div class="container">

<header class="center clearfix" id="navtop"> <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
  <nav class="fright">
    <ul>
      <li><a href="index.html" >Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="documentation.html" class="navactive">Documentation</a></li>
      <li><a href="uc.html">Code</a></li>
      <li><a href="uc.html">Roadmap</a></li>
    </ul>
  </nav>
</header>


<div class="services-page main grid-wrap">

		<header class="grid col-full">
			<hr>
			<p class="fleft" align="right">LEX</p>			<br/><br/>
					<a href="https://github.com/silcnitc/documentation/blob/master/lex/Lex.pdf?raw=true" class="button"> Download as PDF </a>
		</header>
 		
		
    <aside class="grid col-one-quarter mq2-col-full">
		
			<menu>
				<ul>
					<li><a href="#navintro" class="sec" >Introduction</a></li>
					<li><a href="#navstructure" class="sec">The Structure of Lex Programme</a></li>
					<li><a href="#navvariables" class="sec">The yyvariables</a></li>
					<li><a href="#navfunctions" class="sec" >The yyfunctions</a></li>				
					<li><a href="#navcompleteexample" class="sec" >A complete Lex Programme</a></li>
					<li><a href="#navdisambiguation" class="sec" >Disambiguation rules</a></li>
					<li><a href="#navpatternmatching" class="sec" >Pattern Matching Using Lex</a></li>
	            <li><a href="#navsimulator" class="sec" >A token simulator program</a></li>
	            <li><a href="#navdfaconstruction" class="sec" >Construction of a DFA from a regular expression</a></li>			
					<li><a href="#navusingthelexicalanalyzer" class="sec" >Using the generated lexical analyzer</a></li>
					<li><a href="#navreferences" class="sec" >References</a></li>				
				
				</ul>
			</menu>
		</aside>		
		
	  	<section class="grid col-three-quarters mq2-col-full">
		
			<div class="grid-wrap">
		   
		   <article  id="navintro" class="grid col-full">
				<h2>Introduction</h2>
				<p>
				LEX is a tool used to generate a lexical analyzer.
				This document is a tutorial for the use of LEX for SIL Compiler development.
			  Technically, LEX translates a set of regular expression specifications (given as input in input_file.l) into a
			   C implementation of a corresponding finite state machine (lex.yy.c).  
			   This C program, when compiled, yields an executable lexical analyzer.              
				</p>
				<img src="img/lex_1.png" style="max-width:70%" /> 
				<p>The source SIL program is fed as the input to the the lexical analyzer which produces  a sequence of tokens as output. 
				 (Tokens are explained below).Conceptually, a lexical analyzer scans a given source SIL program and produces an output of tokens.
				  A token is a single element of the SIL programming language that is recognized by the compiler. 
				  For instance <b>integer, boolean, begin, end, if, while</b> etc. are tokens in SIL.  
              <br>  
              Example:				  
				  <b> “integer”	&nbsp	{return ID_TYPE_INTEGER;} </b>
				  <br>
				  This example demonstrates the specification of  rule in LEX.
				  This rule in this example specifies that the lexical analyzer must return the token named <b> ID_TYPE_INTEGER</b> when the pattern<b> “integer” </b>
				  is found in the input file.
				   A rule in a LEX program comprises of a pattern part (specified by a regular expression) and a corresponding (semantic) action part (a sequence of C statements). 
				   In the above example, <b> “integer”</b> is the pattern and <b>{return ID_TYPE_INTEGER;}</b> is the corresponding action. The statements in the action part will be executed when the pattern is detected in the input.   


				
				</p>
			</article>
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
			
			 <article  id="navstructure" class="grid col-full">
				<h2>The structure of LEX programs</h2>
				<p>
				A LEX program consists of three sections : Declarations, Rules and Auxiliary functions              
				</p>
				<img src="img/lex_2.png" style="max-width:70%" /> 
             <br>				
				<p> <big><b>2.1 Declarations</b></big>  
              <br>  
              The declarations section consists of two parts, regular definitions and auxiliary declarations.
               LEX allows the use of short-hands and extensions to regular expressions for the regular definitions.
               The auxiliary declarations are copied as such by LEX to the output lex.yy.c file.
               <br>
               <b>Example : </b>
               						<div class="syntax"> 
<pre>
%{
	#include "stdio.h"
	int global_variable; 		//Auxiliary declarations 
%}
number 	[0-9]+				//Regular definitions
op 		[-|+|*|/|^|=]	
		
%%
	/* Rules */
%%
	/* Auxiliary functions */
 </pre>
						</div>
						<br>
						A regular definition in LEX is of the form :
							D &nbsp	R  
						<br>
						where <b>D</b> is the  symbol representing the regular expression <b>R</b>. 
						The auxiliary declarations (which are optional) are written in C language and are enclosed within   ' %{ ' and ' %} ' .
						 It is generally used to declare functions, include header files, or define global variables and constants.
				
				</p>
         <p> <big><b>2.2 Rules</b></big> 
         </p>
         <p>
         Rules in a LEX program consists of two parts :         
         </p> 
         <ol>
          <li> The pattern to be matched</li>
          <li> The corresponding action to be executed</li>
         </ol> 
		  <b> Example :</b>
               						<div class="syntax"> 
<pre>

	/* Declarations*/
%%

{number}	{printf(“ number”);}
{op}		{printf(“ operator”);}

%%
	/* Auxiliary functions */

</pre>
						</div>

      <p> The pattern to be matched is specified as a regular expression.<br>Sample Input/Output for the above example: </p>
<div class="syntax"> 
<pre>
I: 234
O:  number

I: *
O:  operator


I: 2+3
O:  number operator number
</pre>
						</div>
						
          <p> LEX obtains the regular expressions of the symbols <b>number</b> and <b>op</b> from 
	          the declarations section and generates code into a function <b>yylex()</b> in the <b>lex.yy.c</b> file.
            This function checks the input stream for the first match to one of the patterns
             specified and executes code in the action part corresponding to the pattern.  </p>
             
             
      <p> <big><b>2.3 Auxiliary functions</b></big> </p>
      <p> LEX generates C code for the rules specified in the Rules section and places this code into a single function called <b>yylex()</b>. 
       (To be discussed in detail later).
        In addition to this LEX generated code, the programmer may wish to add his own code to the <b>lex.yy.c</b> file. 
         The auxiliary functions section allows the programmer to achieve this.</p>   
         
         <b> Example :</b>
            <div class="syntax"> 
<pre>

	/* Declarations */
%%
	/* Rules */
%%

int main()
{
	yylex();
	return 1;
}
</pre>
						</div>
		The C code in the auxiliary section and the declarations in the declaration section are copied as such to the lex.yy.c file

			</article>	
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
		   
		  
		  <article  id="navvariables" class="grid col-full">
        <h2>The yyvariables</h2>		  
        <p> The following variables are offered by LEX to aid the programmer in designing sophisticated lexical analyzers.
         These variables are accessible in the LEX program and are automatically declared by LEX in lex.yy.c.</p>
         <ul>
        <li><b>yyin</b></li>
        <li><b>yytext</b></li>
        <li><b>yyleng</b></li>          
          </ul>
          <p> <big><b>3.1 &nbspyyin</b></big> </p> 
          <p><b>yyin</b> is a variable of the type <b>FILE*</b> and points to the input file.
            yyin is defined by LEX automatically. 
            If the programmer assigns an input file to <b>yyin</b> in the auxiliary functions section, then <b>yyin</b> is set to point to that file.
            Otherwise LEX assigns <b>yyin</b> to <b>stdin</b>(console input). </p>
          <b>Example :</b>
                      <div class="syntax"> 
<pre>

	/* Declarations */
%%
	/* Rules */
%%
main(int argc, char* argv[]) 
{ 
	if(argc > 1) 
		{	 
			FILE *fp = fopen(argv[1], “r”
			if(fp)
				yyin = fp;
		}
	yylex(); 
	return 1;
}
</pre>
						</div>
						
		<b>Excercise</b>
		<p> In the generated lex.yy.c, the following code segment can be found under the definition of <b>yylex()</b>.</p>	
		                      <div class="syntax"> 
<pre>
if( ! yyin ) 
	yyin = stdin;
</pre>
						</div>	
						
		<p> Try to locate this code segment in the lex.yy.c.
		 What could be the consequences of removing this code segment from <b>lex.yy.c</b> before compiling it for generating the
		  lexical analyzer?
   The above statement indicates that if the programmer does not define <b>yyin</b>, then <b>yylex()</b> by default sets <b>yyin</b>  to the console input.
 Hence, any re-definition for <b>yyin</b> must be made before invoking <b>yylex()</b>.  (This will be explained in detail later).  </p>	
 
 <p> <big><b>3.2 &nbspyytext</b></big> </p>
 <p> <b>yytext</b> is of the type <b>char*</b> and it contains the lexeme currently found.
   A lexeme is a sequence of characters in the input stream that matches some pattern in the Rules Section. 
   (In fact, it is the first matching sequence in the input from the position pointed to by <b>yyin</b>.)    

 Each invocation of the function <b>yylex()</b> results in <b>yytext</b> carrying a pointer to the lexeme found in
  the input stream by <b>yylex()</b>.
 The value of <b>yytext</b> will be overwritten after the next <b>yylex()</b> invocation.</p>
 	<b> Example</b>
          
          		                      <div class="syntax"> 
<pre>
{%
	#include &ltstdlib.h&gt
	#include &ltstdio.h&gt
%}
number 	[0-9]+

%%
{number}	{printf("Found : %d",atoi(yytext));}
%%

int main()
{
	yylex();
	return 1;
}
</pre>
						</div>
          
		  
		  <p> In the above example, if a lexeme is found for the pattern defined by <b>number</b> then corresponding action is executed .
		   Consider the following sample i/o,</p>
        <br>
        Sample Input/Output:	
        		                      <div class="syntax"> 
<pre>
I: 25
O: Found : 25
</pre>
						</div>		   
		   <p> In this case when <b>yylex()</b> is called, the input is read from the location given by <b>yyin</b> and a string  “25” is found as a match to
		   <b>number</b>.
		    This location of this string in the memory is pointed to by <b>yytext</b>.
		     The corresponding action in the above rule uses a built-in function <b>atoi()</b> to convert the string <b>“25”</b> (of type <b>char*</b>) to the integer <b>25</b> (of the type <b>int</b>) and then prints the result on the screen.
		    Note that the header file <b>“stdlib.h”</b> is called in the auxiliary declarations section in order to invoke <b>atoi()</b> in
		     the actions part of the rule.</p>
		    <br>
		    <b>Exercise:</b>

<p> <i>Suggest a modification in the above example to check whether a number found is even or odd.
</i></p>

<p> <big><b>3.3 &nbspyyleng</b></big> </p>
<p> <b>yyleng</b> is a variable of the type <b>int</b> and it stores the length of the lexeme pointed to by <b>yytext</b>.</p>

<b>Example</b>
			<div class="syntax"> 
<pre>
/* Declarations */
%%
	/* Rules */
%%
{number}	printf("Number of digits =  %d",yyleng);
</pre>
						</div>
						<b>Sample Input/Output</b>	
						
			<div class="syntax"> 
<pre>
I: 1234
O: Number of digits = 4
</pre>
						</div>	   

</article>
		
		<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
			
			
 <article  id="navfunctions" class="grid col-full">
        <h2>The yyfunctions</h2>	
        <ul>
     <li><b> yylex()</b></li>         
     <li> <b>yywrap()</b></li>
         </ul>
<p> <big><b>4.1 &nbspyylex()</b></big> </p
<p> <b>yylex()</b> is a function of return type <b>int</b>. LEX automatically defines <b>yylex()</b> in lex.yy.c but does not call it.
     The programmer must call <b>yylex()</b> in the Auxiliary functions section of the LEX program.
    LEX generates code for the definition of <b>yylex()</b> according to the rules specified in the Rules section. </p>
    <b> Example :</b>
    	<div class="syntax"> 
<pre>
/* Declarations */
%%

{number}	{return atoi(yytext);}

%%

int main()
{
	int num = yylex();
	printf(“Found: %d”,num);
	return 1;
}
</pre>
						</div>	   

<p> Sample Input/Output :</p>

<div class="syntax"> 
<pre>
I: 42
O: Found: 42
</pre>
						</div>	 
						
<p> When <b>yylex()</b> is invoked, it reads the input as pointed to by <b>yyin</b> and scans 
through the input looking for a matching pattern. When the input or a part of the input
matches one of the given patterns, <b>yylex()</b> executes the corresponding action associated 
with the pattern as specified in the Rules section. 
In the above example, since there is no explicit definition of
 <b>yyin</b>, the input is taken from the console. If a match is found in the
  input for the pattern number, <b>yylex()</b> executes the corresponding action , i.e.
   return <b>atoi(yytext)</b>. As a result <b>yylex()</b> returns the number matched. The value returned by <b>yylex()</b> is
    stored in the variable <b>num</b>. 
The value stored in this variable is then printed on screen using <b>printf()</b>.</p>	
<p> <b>yylex()</b> continues scanning through the input
 till one of the actions corresponding to a matched pattern 
 executes a <b>return</b> statement or till the end of input (<i>input end-marker</i> ) has
  been encountered. In case of the above example, <b>yylex()</b> terminates immediately after executing the rule because it consists
   of a return statement.
 Note that if none of the actions in the Rules section executes a return statement, <b>yylex()</b>would:</p>		
 <ul>
<li>(In case of an input file) continue scanning for more matching patterns till it finds <b>EOF</b> in the file
  </li>
  <li> (In case of console input) wait for more input through the console</li> 
 
 </ul>	
 <p> In the latter case, since there is no input end-marker, the user will have to input <b>ctrl+d</b>  in the terminal
  to indicate the end of input. As a result, yylex() will terminate.
<br>
 <b> NOTE :</b> 
  If <b>yylex()</b> is called more than once, it simply starts scanning from
   the position in the input file where it had ceased in the previous call.
    </p>		
	<p> 
 <i> <b> Excercise:</b>
 
What would be the outputs of the lexical analyzer generated by 
the example LEX programs under section 3.2 and 4.1 for the following input : 
 </i> <br> 25 <br> 32 <br> 44 <br> 
 <i> Would both the outputs be the same ? If not, explain why.</i>
	</p>
	
	
	<p> <big><b>4.2 &nbsp yywrap()</b></big> </p			
	<p>LEX declares the function <b>yywrap()</b> of return type <b>int</b> in lex.yy.c . 
	LEX does not provide any definition for <b>yywrap()</b>. <b>yylex()</b> makes makes a call to <b>yywrap()</b>
	 when it encounters the end of an input. If <b>yywrap()</b> returns zero (indicating <i>false</i>) <b>yylex()</b> assumes
	  there is more input and it continues scanning from the location pointed to by <b>yyin</b>. 
	  If <b>yywrap()</b> returns a non-zero value (indicating true), 
	<b>yylex()</b> terminates the scanning process and returns 0 (i.e. “wraps up”).
	<br>
   	If the programmer wishes to scan more than one input file using the generated lexical analyzer,
	 it can be simply done by setting <b>yyin</b> to a new input file in <b>yywrap()</b>'s definition which returns zero.
	</p>
	<p> As LEX does not define <b>yywrap()</b> in lex.yy.c file but
	 makes a call to it under <b>yylex()</b>,
	  the programmer must define it in the Auxiliary functions section 
	  or provide <b>%option noyywrap</b> in the declarations section. 
	  This options removes the call to yywrap() in the lex.yy.c file. Note that, it is <big><b>mandatory</b> </big>to either define yywrap()
	  or indicate the absence using the <b>%option</b> feature. If not, LEX will flag an error</p>	
	  <b>Example</b>
	  	
						
		<div class="syntax"> 
<pre>

	/* Declarations */
%%
	/* Rules */
%%

int yywrap()
{
	FILE *newfile_pointer;
	newfile_pointer = fopen(“input_file_2.l”,”r”);
	if(yyin != newfile_pointer)	
	{
		yyin = newfile_pointer;
		return 0;
	}
	else
		return 1;
}

int main()
{
	yyin=fopen(“input_file.l”,”r”);
	yylex();
	return 1;
}
</pre>
						</div>
						
		<p> When <b>yylex()</b> finishes scanning the first input file, <b>input_file.l</b> <b>yylex()</b> invokes <b>yywrap()</b>. 
		The above definition of <b>yywrap()</b> sets the input file pointer to <b>input_file_2.l</b> and returns 0 .
		 As a result, the scanner continues scanning in <b>input_file_2.l</b> .
 When <b>yylex()</b> calls <b>yywrap()</b> on encountering <b>EOF</b> of <b>input_file_2.l</b>, <b>yywrap()</b> returns 0 and thus <b>yylex()</b> ceases scanning.</p>				

<i><b> Excercise :</b> 
Suggest a modification in the above example LEX program to make the generated lexical analyzer read input
<ul>
<li> Initially from the console and then from a file <b>input_file.l</b></li>
<li> Initially from a file <b>input_file.l</b> and then from the console</li>
<li> Twice from the console</li>

</ul>



</i>

        </article>
        
   <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
	</div>
        <article  id="navcompleteexample" class="grid col-full">
        <h2>Even-Odd.l , a complete LEX program</h2>	
        <div class="syntax"> 
<pre>

%{ 
/* 
1.Request input of an even and an odd number 
2.indicate input characteristic : Even/Odd [digit_length] 
3.check for input's correctness and print result 
*/ 

#include &ltstdlib.h&gt  
#include &ltstdio.h&gt

int number_1; 
int number_2; 
%} 


number_sequence [0-9]* 

%% 

{number_sequence}[0|2|4|6|8]		{ 
						printf("Even number [%d]",yyleng); 
						return atoi(yytext); 
					} 

{number_sequence}[1|3|5|7|9]		{ 
						printf("Odd number [%d]",yyleng);	 
						return atoi(yytext); 
					} 
%% 

int yywrap 
{ 
 	return 1; 
} 
 
int main() 
{ 
	printf("\nInput an even number and an odd number\n"); 
 	number_1 = yylex(); 
	number_2 = yylex(); 
	int diff = number_1 - number_2; 
	if(diff%2!=0) 
		printf("\nYour inputs were checked for correctness, \nResult : Correct\n"); 
	else 
		printf("\nYour inputs were checked for correctness, \nResult : 
		       You do not know how to read\n"); 
	return 1; 
}
</pre>
						</div>
              
        
        </article>
        
     <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
	</div>
	
	<article  id="navdisambiguation" class="grid col-full">
        <h2>Disambiguation Rules</h2>	
        <p> <b>yylex()</b> uses two important disambiguation rules in selecting the right action to execute
         in case there is more than one pattern that matches a string in the given input: </p>
         <ol>
     <li> Order of occurrence is assigned as the pattern's matching priority.</li>         
     <li>“Longest match” is preferred. 
     </li>
         </ol>
 <b> Example :</b>
 
<div class="syntax"> 
<pre>
   “break”                 { return BREAK; }
   [a-zA-Z][a-zA-Z0-9]*    { return IDENTIFIER; }
</pre>
						</div>
	<p> Here, <b>break</b> is matched by both the regular expressions,
	 but <b>break</b> is a keyword and not an identifier hence it is ordered
	    in such a manner that LEX uses its first disambiguation rule to execute <b>return BREAK</b>;</p>
     <b> Example :</b>
   <div class="syntax"> 
<pre>
/* Declarations section */
%%

“-”		{return MINUS;}
“--”		{return DECREMENT;}

%%
	/* Auxiliary functions */
</pre>
						</div>  
						<p> Assume that the function calling yylex() prints the name of the token.</p>       
         <b>  Sample Input/Output :</b>
            <div class="syntax"> 
<pre>
I: -
O: MINUS

I: --
O: DECREMENT

I: ---
O: DECREMENT MINUS
</pre>
						</div>
						
						<p>Note that, in case of an<b> ---</b> input to the lexical analyzer, <b>yylex()</b> does not return two <b>MINUS</b> tokens,
						 but instead returns a <b>DECREMENT</b> token, by the second disambiguation rule.</p>
         
	
	</article>
	 <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
	</div>
		<article  id="navpatternmatching" class="grid col-full">
        <h2>Pattern matching using LEX</h2>
	<p> Conceptually, LEX constructs a finite state machine to recognize all the regular expression patterns specified
	 in the LEX program file.  The code written by the programmer in the action part is executed when the machine is in accept state. 
	 The lex.yy.c program stores information about the finite state machine in the form of a decision table (transition table).   
 	A <b>transition(current_state,input_char)</b> function is used to access the decision table.
 	 LEX makes it's decision table visible if we compile the program with the -T flag. 
 	 The finite state machine used by LEX is deterministic finite state automation.  The lex.yy.c simulates the DFA. </p>
	</article>	
				 <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
	</div>
			
			
			
			
			
			</div>
		</section>
		
		
		
   		

  		
	   
	   
	</div>










</div>














</body>

</html>