<!Doctype html>
<html lang="en">
<head>
<title>LEX</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="css/style.css">
</head>
<body>
 <header class="center clearfix" id="navtop"> <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
  <nav class="fright">
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="documentation.html" class="navactive">Documentation</a></li>
      <li><a href="uc.html">Code</a></li>
      <li><a href="uc.html">Roadmap</a></li>
    </ul>
  </nav>
</header>
<div class="about center part clearfix">
<header class="title">
<h3 class="fleft">Contents</h3>	
</header>
    <aside class="column4 mright">
<menu>
<ul>
<li><a href="#navintro" class="sec">Introduction</a></li>
<li><a href="#navstructure" class="sec">Structure of a LEX Program</a></li>
<li><a href="#navvariables" class="sec">yyvariables</a></li>
<li><a href="#navfunctions" class="sec">yyfunctions</a></li>	
<li><a href="#navcompleteexample" class="sec">A complete LEX Program</a></li>
<li><a href="#navdisambiguation" class="sec">Disambiguation rules</a></li>
<li><a href="#navpatternmatching" class="sec">Pattern Matching Using LEX</a></li>
<li><a href="#navsimulator" class="sec">A token simulator program</a></li>
<li><a href="#navdfaconstruction" class="sec">DFA -> regular expression</a><li>	
<li><a href="#navusingthelexicalanalyzer" class="sec">Using the generated lexical analyzer</a></li>
<li><a href="#navreferences" class="sec">References</a></li>
<li><!--For blank space between lins and download button--> &nbsp;</li>	
<li><a href="https://github.com/silcnitc/documentation/blob/master/lex/Lex.pdf?raw=true" class="button"> Download as PDF </a></li>
<li><!--Blank line for space between download button and main title--> &nbsp;</li>	
</ul>
</menu>

</aside>	

<section class="columnthird content"><h1 class="mright">USING LEX</h1>
<article id="navintro" class="detail">
<h2>Introduction</h2>
<p>
LEX is a tool used to generate a lexical analyzer.
This document is a tutorial for the use of LEX for SIL Compiler development.
Technically, LEX translates a set of regular expression specifications (given as input in input_file.l) into a C implementation of a corresponding finite state machine (lex.yy.c). This C program, when compiled, yields an executable lexical analyzer.
</p>
<img src="img/lex_1.png" style="max-width:70%">
<p>The source SIL program is fed as the input to the the lexical analyzer which produces a sequence of tokens as output.
(Tokens are explained below).Conceptually, a lexical analyzer scans a given source SIL program and produces an output of tokens.
A token is a single element of the SIL programming language that is recognized by the compiler.
For instance integer, boolean, begin, end, if, while etc. are tokens in SIL.

<div class="syntax">
“integer” &nbsp;	{return ID_TYPE_INTEGER;}
</div>

This example demonstrates the specification of a <i>rule</i> in LEX.
The rule in this example specifies that the lexical analyzer must return the token named  ID_TYPE_INTEGER when the pattern “integer” 
is found in the input file.
A <i>rule</i> in a LEX program comprises of a pattern part (specified by a regular expression) and a corresponding (semantic) action part (a sequence of C statements).
In the above example,  “integer” is the pattern and {return ID_TYPE_INTEGER;} is the corresponding action. The statements in the action part will be executed when the pattern is detected in the input.
</p>
</article>

<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>

<article id="navstructure" class="detail">
<h2>The structure of LEX programs</h2>
<p>
A LEX program consists of three sections : <i>Declarations</i>, <i>Rules</i> and <i>Auxiliary functions</i>
</p>
<img src="img/lex_2.png" style="max-width:70%">
             <br>	
<p> <big>2.1 Declarations</big>
              <br>
              The declarations section consists of two parts, <i>regular definitions</i> and <i>auxiliary declarations</i>.
               LEX allows the use of short-hands and extensions to regular expressions for the regular definitions.
               The auxiliary declarations are copied as such by LEX to the output lex.yy.c file. The C code consists of instructions to the C compiler and are not processed by the LEX tool.
               <br>
               Example : 
                </p>
<div class="syntax">
<pre>
/*Declarations section start here*/

/* Auxiliary declarations start here*/
%{
	#include &lt;stdio.h&gt;
	int global_variable; 
%}
/*Auxiliary declarations end & Regular definitions start here*/

	number [0-9]+ 		//Regular definition
	op [-|+|*|/|^|=]	//Regular definition

/*Declarations section ends here*/
%%
/* Rules */
%%
/* Auxiliary functions */
</pre>
</div> 
<p></p>
<p><br>
A regular definition in LEX is of the form :
D &nbsp;	R
<br>
where D is the symbol representing the regular expression R.
The auxiliary declarations (which are optional) are written in C language and are enclosed within ' %{ ' and ' %} ' .
It is generally used to declare functions, include header files, or define global variables and constants. 

</p>
         <p> <big>2.2 Rules</big>
         </p>
         <p>
         Rules in a LEX program consists of two parts :
         </p>
         
          <p><i>The pattern to be matched</i></p>
          <p><big>The corresponding action to be executed</big></p>

 Example :
                <div class="syntax">
<pre>	/* Declarations*/
%%
	
	{number} {printf(“ number”);}
	{op} {printf(“ operator”);}

%%
/* Auxiliary functions */

</pre>
</div>

      <p> The pattern to be matched is specified as a regular expression.<br>Sample Input/Output for the above example: </p>
<div class="syntax">
<pre>I: 234
O: number

I: *
O: operator


I: 2+3
O: number operator number
</pre>
</div>

          <p> LEX obtains the regular expressions of the symbols number and op from
the declarations section and generates code into a function yylex() in the lex.yy.c file.
            This function checks the input stream for the first match to one of the patterns
             specified and executes code in the action part corresponding to the pattern. </p>
             
             
      <p> <big>2.3 Auxiliary functions</big> </p>
      <p> LEX generates C code for the rules specified in the Rules section and places this code into a single function called yylex().
       (To be discussed in detail later).
        In addition to this LEX generated code, the programmer may wish to add his own code to the lex.yy.c file.
         The auxiliary functions section allows the programmer to achieve this.</p>
         
          Example :
<div id = "navexl0" class="syntax">
<pre>/* Declarations */
%%
	/* Rules */
%%
int main()
{
	yylex();
	return 1;
}
</pre>
</div>
<p>The C code in the auxiliary section and the declarations in the declaration section are copied as such to the lex.yy.c file
 </p>
  </article>	
<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>	
<article id="navvariables" class="detail">
        <h2>The yyvariables</h2>	
        <p> The following variables are offered by LEX to aid the programmer in designing sophisticated lexical analyzers.
         These variables are accessible in the LEX program and are automatically declared by LEX in lex.yy.c.</p>
         <ul>
        <li>yyin</li>
        <li>yytext</li>
        <li>yyleng</li>
          </ul>
          <p> <big>3.1 &nbsp;yyin</big> </p>
          <p>yyin is a variable of the type FILE* and points to the input file.
            yyin is defined by LEX automatically.
            If the programmer assigns an input file to yyin in the auxiliary functions section, then yyin is set to point to that file.
            Otherwise LEX assigns yyin to stdin(console input). </p>
          Example :
<div class="syntax">
<pre>/* Declarations */
%%
/* Rules */
%%
main(int argc, char* argv[])
{
	if(argc &gt; 1)
	{
		FILE *fp = fopen(argv[1], “r”
		if(fp)
			yyin = fp;
	}
	yylex();
	return 1;
}
</pre>
</div>

Excercise
<p> In the generated lex.yy.c, the following code segment can be found under the definition of yylex().</p>	
<div class="syntax">
<pre>if( ! yyin )
yyin = stdin;
</pre>
</div>	

<p> Try to locate this code segment in the lex.yy.c.
What could be the consequences of removing this code segment from lex.yy.c before compiling it for generating the
lexical analyzer?
   The above statement indicates that if the programmer does not define yyin, then yylex() by default sets yyin to the console input.
 Hence, any re-definition for yyin must be made before invoking yylex(). (This will be explained in detail later). </p>	
 
 <p> <big>3.2 &nbsp;yytext</big> </p>
 <p> yytext is of the type char* and it contains the <i><big>lexeme</big></i> currently found.
   A <i>lexeme</i> is a sequence of characters in the input stream that matches some pattern in the Rules Section.
   (In fact, it is the first matching sequence in the input from the position pointed to by yyin.)

 Each invocation of the function yylex() results in yytext carrying a pointer to the lexeme found in
  the input stream by yylex().
 The value of yytext will be overwritten after the next yylex() invocation.</p>
   Example
          
           <div class="syntax">
<pre>{%
	#include &lt;stdlib.h&gt;
	#include &lt;stdio.h&gt;
%}
	
number [0-9]+

%%

{number} {printf("Found : %d",atoi(yytext));}

%%

int main()
{
	yylex();
	return 1;
}
</div>
</pre>
          

<p> In the above example, if a lexeme is found for the pattern defined by number then corresponding action is executed .
Consider the following sample i/o,</p>
        <br>
        Sample Input/Output:
         <div class="syntax">
<pre>I: 25
O: Found : 25
</pre>
</div>	
<p> In this case when yylex() is called, the input is read from the location given by yyin and a string “25” is found as a match to
number.
This location of this string in the memory is pointed to by yytext.
The corresponding action in the above rule uses a built-in function atoi() to convert the string “25” (of type char*) to the integer 25 (of the type int) and then prints the result on the screen.
Note that the header file “stdlib.h” is called in the auxiliary declarations section in order to invoke atoi() in
the actions part of the rule.</p>
<br>
<p>
NOTE: The lexeme found by LEX is stored in some memory allocated by LEX which can be accessed through the character pointer yytext. 
</p>
Exercise:

<p> <i>Suggest a modification in the above example to check whether a number found is even or odd.
</i></p>

<p> <big>3.3 &nbsp;yyleng</big> </p>
<p> yyleng is a variable of the type int and it stores the length of the lexeme pointed to by yytext.</p>

Example
<div class="syntax">
<pre>/* Declarations */
%%
/* Rules */
%%
{number} printf("Number of digits = %d",yyleng);
</pre>
</div>
Sample Input/Output	

<div class="syntax">
<pre>I: 1234
O: Number of digits = 4
</pre>
</div>	

</article>

<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>


 <article id="navfunctions" class="detail">
        <h2>The yyfunctions</h2>	
        <ul>
     <li> yylex()</li>
     <li> yywrap()</li>
         </ul>
<p> <big>4.1 &nbsp;yylex()</big> </p>
<p> yylex() is a function of return type int. LEX automatically defines yylex() in lex.yy.c but does not call it.
     The programmer must call yylex() in the Auxiliary functions section of the LEX program.
    LEX generates code for the definition of yylex() according to the rules specified in the Rules section. </p>
	<p>NOTE: That yylex() need not necessarily be invoked in the Auxilar</p>
     Example :
     <div class="syntax">
<pre>/* Declarations */
%%

{number} {return atoi(yytext);}

%%

int main()
{
	int num = yylex();
	printf(“Found: %d”,num);
	return 1;
}
</pre>
</div>	

<p> Sample Input/Output :</p>

<div class="syntax">
<pre>I: 42
O: Found: 42
</pre>
</div>	

<p> When yylex() is invoked, it reads the input as pointed to by yyin and scans
through the input looking for a matching pattern. When the input or a part of the input
matches one of the given patterns, yylex() executes the corresponding action associated
with the pattern as specified in the Rules section.
In the above example, since there is no explicit definition of
 yyin, the input is taken from the console. If a match is found in the
  input for the pattern <b>number</b>, yylex() executes the corresponding action , i.e.
   return atoi(yytext). As a result yylex() returns the number matched. The value returned by yylex() is
    stored in the variable num.
The value stored in this variable is then printed on screen using printf().</p>	
<p> yylex() continues scanning the input
 till one of the actions corresponding to a matched pattern
 executes a return statement or till the end of input has
  been encountered. In case of the above example, yylex() terminates immediately after executing the rule because it consists
   of a return statement.
 <p>Note that if none of the actions in the Rules section executes a return statement, yylex() continues scanning for more matching patterns in the input file till the end of the file.</p>	
  <p> In the case of console input, yylex() would wait for more input through the console. The user will have to input ctrl+d in the terminal to terminate yylex(). If yylex() is called more than once, it simply starts scanning from the position in the input file where it had returned in the previous call.
    </p>	
<p>
 <i>  Excercise:
 
What would be the outputs of the lexical analyzer generated by
the example LEX programs under section 3.2 and 4.1 for the following input :
 </i> <br> 25 <br> 32 <br> 44 <br>
 <i> Would both the outputs be the same ? If not, explain why.</i>
</p>


<p> <big>4.2 &nbsp; yywrap()</big> </p>	
<p>LEX declares the function yywrap() of return-type int in lex.yy.c .
LEX does not provide any definition for yywrap(). yylex() makes a call to yywrap()
when it encounters the end of input. If yywrap() returns zero (indicating <i>false</i>) yylex() assumes
there is more input and it continues scanning from the location pointed to by yyin.
If yywrap() returns a non-zero value (indicating true),
yylex() terminates the scanning process and returns 0 (i.e. “wraps up”).
    If the programmer wishes to scan more than one input file using the generated lexical analyzer,
it can be simply done by setting yyin to a new input file in yywrap() and return 0.
</p>
<p> As LEX does not define yywrap() in lex.yy.c file but
makes a call to it under yylex(),
the programmer must define it in the Auxiliary functions section
or provide %option noyywrap in the declarations section.
This options removes the call to yywrap() in the lex.yy.c file. Note that, it is <b>mandatory </b>to either define yywrap()
or indicate the absence using the %option feature. If not, LEX will flag an error</p>	
Example


<div class="syntax">
<pre>	/* Declarations */
%%
/* Rules */
%%

int yywrap()
{
FILE *newfile_pointer;
newfile_pointer = fopen(“input_file_2.l”,”r”);
if(yyin != newfile_pointer)
{
yyin = newfile_pointer;
return 0;
}
else
return 1;
}

int main()
{
yyin=fopen(“input_file.l”,”r”);
yylex();
return 1;
}
</pre>
</div>

<p> When yylex() finishes scanning the first input file, input_file.l yylex() invokes yywrap().
The above definition of yywrap() sets the input file pointer to input_file_2.l and returns 0 .
As a result, the scanner continues scanning in input_file_2.l .
 When yylex() calls yywrap() on encountering EOF of input_file_2.l, yywrap() returns 0 and thus yylex() ceases scanning.</p>	

<i> Excercise :
Suggest a modification in the above example LEX program to make the generated lexical analyzer read input
<ul>
<li> Initially from the console and then from a file input_file.l</li>
<li> Initially from a file input_file.l and then from the console</li>
<li> Twice from the console</li>

</ul>



</i>

        </article>
        
   <div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>
        <article id="navcompleteexample" class="detail">
        <h2>Even-Odd.l , a complete LEX program</h2>	
        <div class="syntax">
<pre>%{
/*
1.Request input of an even and an odd number
2.indicate input characteristic : Even/Odd [digit_length]
3.check for input's correctness and print result
*/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int number_1;
int number_2;
%}


number_sequence [0-9]*

%%

{number_sequence}[0|2|4|6|8] {
printf("Even number [%d]",yyleng);
return atoi(yytext);
}

{number_sequence}[1|3|5|7|9] {
printf("Odd number [%d]",yyleng);
return atoi(yytext);
}
%%

int yywrap
{
  return 1;
}
 
int main()
{
printf("\nInput an even number and an odd number\n");
  number_1 = yylex();
number_2 = yylex();
int diff = number_1 - number_2;
if(diff%2!=0)
printf("\nYour inputs were checked for correctness, \nResult : Correct\n");
else
printf("\nYour inputs were checked for correctness, \nResult :
You do not know how to read\n");
return 1;
}
</pre>
</div>
              
        
        </article>
        
     <div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>

<article id="navdisambiguation" class="detail">
        <h2>Disambiguation Rules</h2>	
        <p> yylex() uses two important disambiguation rules in selecting the right action to execute
         in case there is more than one pattern that matches a string in the given input: </p>
         <ol>
     <li> Order of occurrence is assigned as the pattern's matching priority.</li>
     <li>“Longest match” is preferred.
     </li>
         </ol>
  Example :
 
<div class="syntax">
<pre> “break” { return BREAK; }
   [a-zA-Z][a-zA-Z0-9]* { return IDENTIFIER; }
</pre>
</div>
<p> If "break" is found in the input, it is matched with the first pattern and yylex() returns BREAK. If "breakdown" is found, it is matched with the second pattern and yylex() returns IDENTIFIER. Note the use of disambiguation rules here. </p>
      Example :
   <div class="syntax">
<pre>/* Declarations section */
%%

“-” {return MINUS;}
“--” {return DECREMENT;}

%%
/* Auxiliary functions */
</pre>
</div>
<p> Assume that the function calling yylex() prints the name of the token.</p>
          Sample Input/Output :
            <div class="syntax">
<pre>I: -
O: MINUS
&lt;
I: --
O: DECREMENT

I: ---
O: DECREMENT MINUS
</pre>
</div>

<p>Note that, in case of an -- input to the lexical analyzer, yylex() does not return two MINUS tokens,
but instead returns a DECREMENT token, by the second disambiguation rule.</p>
         

</article>
<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>
<article id="navpatternmatching" class="detail">
        <h2>Pattern matching using LEX</h2>
<p> Conceptually, LEX constructs a finite state machine to recognize all the regular expression patterns specified
in the LEX program file. The code written by the programmer in the action part is executed when the machine is in accept state.
The lex.yy.c program stores information about the finite state machine in the form of a decision table (transition table).
  A transition(current_state,input_char) function is used to access the decision table.
  LEX makes it's decision table visible if we compile the program with the -T flag.
  The finite state machine used by LEX is deterministic finite state automation. The lex.yy.c simulates the DFA. </p>
</article>	
<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>

<article id="navsimulator" class="detail">
        <h2>A token simulator program</h2>
<div class="syntax">
<pre>%{
/* Scan and return a token for identifiers of the format :
             (string)(number)
Note : strings are not case sensitive
examples : a0 , A1 , ab2 , AB4 , aBc5
*/
#include<stdio.h>

#define ID 1 //Identifier token
#define ER 2 //Error token

%}
low_case [a-z]
upp_case [A-Z]
number [0-9]

%option noyywrap

%%
({low_case}|{upp_case})({low_case}|{upp_case})*({number})
return ID;
(.)* return ER;

%%
int main()
{
int token = yylex();
if(token==ID)
printf("Acceptable\n");
else if(token==ER)
printf("Unacceptable\n");
return 1;
}
</stdio.h></pre>
</div>

<p>In this program, the main() function obtains the tokens returned by yylex() and checks if the input contains a valid identifier.
</p>

 Sample Input/Output : 
<div class="syntax">
<pre>I: Var9
O: Acceptable
</pre>
</div>
<p> When Var9 is provided as the input, the DFA constructed by LEX accepts the string,
and the corresponding action return ID executed.
As a result yylex() returns the token ID, and the main() function prints Acceptable on the screen. </p>
   
         
   
   </article>	
   
    <div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>

<article id="navdfaconstruction" class="detail">
        <h2>Construction of a DFA from a regular expression</h2>
<p> The construction of a DFA from a regular expression takes place in two steps.</p>
<ul>
          <li>Constructing a syntax tree from the regular expression
           </li>	
           <li> Converting the syntax tree into a DFA </li>
           
        </ul>
       
       <big> 9.1 The intermediate syntax tree</big>	
       <p> Consider the first rule in the token simulator program in section 8.
        It consists of the following regular expression :</p>
           ({low_case}|{upp_case})({low_case}|{upp_case})*({number})
           <p>For convenience in representation , let it be represented by :</p>
            ( a | A ) ( a | A )* (N)
           <p>where, 'a' represents {low_case}, 'A' represents {upp_case} and 'N' represents {number}.
             The syntax tree constructed for the above regular expression would look like : </p>
             <img src="img/lex_5.png" style="max-width:70%">
             <p> In the above figure  º represents the 'cat' (concatenation) operator,
             * represents the 'star' operator (a unary operator) and | represents the
              'or' operator. In the syntax tree the inner nodes are operators
               while the leaves are the operands.
               The subscript assigned to every leaf is called the position of the leaf.
                The position of a leaf plays a vital role in the process of constructing states for the DFA.
             </p>
             
             <p> NOTE:
             <br>
      This syntax tree is an intermediate data structure.
     There will be no traces of this in lex.yy.c file, because it is only used in the construction of the DFA.</p>
     
     <big> 9.2 The intermediate syntax tree</big>	
      <p>Constructing the DFA involves two steps:</p>
       <ul>
      <li>Constructing the set of states of the DFA</li>
        <li>Constructing all the possible transitions made by the DFA from one state to another on different inputs. </li>
       </ul>
<p> The language represented by the regular expression ( a | A ) ( a | A )* (N),
can only possibly start with an 'a' or 'A'. From the syntax tree we may infer that these could only correspond to positions 1 or 2 . Let the set of these positions {1,2} be the start state of the DFA.
For convenience it has been named as state I.</p>
<p> Consider the position 1 ('a'), it could be followed by either of the positions 3,4 or 5.
Let this be a new state {3,4,5} represented by II.
The position 2 ('A') could be possibly followed by either of the positions 3,4 or 5.
But a new state is not required as {3,4,5} has already been represented by II.
Similarly the positions 3 and 4 could be followed by the position 3 or 4 or 5.
If followed by 5, the DFA must accept and terminate (syntax tree ends at position 5).
Hence let the final (accept) state be III.
Thus, the transitions maybe formulated as :</p>

    <img src="img/lex_3.jpeg" style="max-width:70%">
    <br>
    
<big> 9.3 The intermediate syntax tree</big>
<p> The DFA obtained for the above syntax tree would look like :</p>
<img src="img/lex_4.png" style="max-width:70%">
<p> This DFA represents the regular expression provided as a specification
(i.e. pattern to be matched) in the first rule of the token
simulator program in section 9. When the DFA is in the final state i.e. III,
then the corresponding action is executed as instructed in the lex.yy.c file.
The constructed DFA is simulated using a simulation algorithm. </p>
<br>


<big> 9.4 The DFA simulation algorithm</big>
<p> The working of the constructed DFA is simulated using the following algorithm.</p>
<div class="syntax">
<pre>DFA_simulator()
current_state = start_state
c = get_next_char()
while(c != EOF)
current_sate = transition(current_state , c)
  c = get_next_char()
if(current_state ∈ Final_states)
/*ACCEPT*/
else
/*REJECT*/

</pre>
</div>
<p> The information about all the transitions made by the DFA
can be obtained from the decision
table (generally a two dimensional matrix) through the transition() function.
              </p>

</article>
<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>


<article id="navusingthelexicalanalyzer" class="detail">
        <h2>Using the generated lexical analyzer</h2>
<p> The generated lex.yy.c file is the code for the scanner.
This is compiled using a C compiler and the generated object file (the executable scanner)
is executed. LEX is just a tool which helps generate a smart scanner in C.
The lexical analyzer only checks for recognizable pattern sequences in the source program
and produces an output of tokens (fed to the parser) , it cannot be used to check for syntax.
Syntax analysis is done by the parser. The parser is built using YACC , a parser generator.
YACC obtains the tokens from LEX through yylex() and the associated attributes from yylval,
which it uses for parsing and rest of the the compilation process. In this case, the programmer
need not call yylex() in the LEX program, it is automatically called by YACC to read the tokens.
The parser , when given an input source program obtains all the tokens from the lexical analyzer
and checks for correctness of the syntax. Hence, the next step towards compiling a given source program would be to build a parser.
             </p>
</article>

<div class="up grid col-one-third" style="float:right">
<a href="#navtop" title="Go back up"> top ↑</a>
</div>

<article id="navreferences" class="detail">
        <h2>References</h2>
<p> For further details on the topics covered in this document, the reader may refer to the following :</p>
<ul>
<li> Compilers : Principles,Techniques and Tools by Alfred V.Aho, Monica S. Lam, Ravi Sethi and Jeffrey D.Ulman .</li>
      <li>Modern Compiler Implementation in C by Andrew W.Appel</li>
<li> Flex &amp; Bison by John Levine</li>
<li> http://dinosaur.compilertools.net/</li>
</ul>
</article>
<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
	</div>
					</div>
</section>

<footer class="center part clearfix">
<ul class="social column3 mright">
    <li><a href="https://github.com/silcnitc">Github</a></li>
</ul>
  <div class="up column3 mright"> <a href="#navtop" class="ir">Go up</a> </div>
  <nav class="column3">
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="uc.html">Contact</a></li>
    </ul>
  </nav>
</footer>

</body>
<!-- Javascript - jQuery
<script src="http://code.jquery.com/jquery.min.js"></script>-->
<script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>
<!--[if (gte IE 6)&(lte IE 8)]>
<script src="js/selectivizr.js"></script>
<![endif]-->
<script src="js/scripts.js"></script>
</html>
