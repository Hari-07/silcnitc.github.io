<!DOCTYPE html>
<html lang="en">
<head>
<title>LEX</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="css/style.css">
<!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body>
<div class="container">

<header class="center clearfix" id="navtop"> <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
  <nav class="fright">
    <ul>
      <li><a href="index.html" >Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="documentation.html" class="navactive">Documentation</a></li>
      <li><a href="uc.html">Code</a></li>
      <li><a href="uc.html">Roadmap</a></li>
    </ul>
  </nav>
</header>


<div class="services-page main grid-wrap">

		<header class="grid col-full">
			<hr>
			<p class="fleft" align="right">LEX</p>			<br/><br/>
					<a href="https://github.com/silcnitc/documentation/blob/master/lex/Lex.pdf?raw=true" class="button"> Download as PDF </a>
		</header>
 		
		
    <aside class="grid col-one-quarter mq2-col-full">
		
			<menu>
				<ul>
					<li><a href="#navintro" class="sec" >Introduction</a></li>
					<li><a href="#navstructure" class="sec">The Structure of Lex Programme</a></li>
					<li><a href="#navvariables" class="sec">The yyvariables</a></li>
					<li><a href="#navfunctions" class="sec" >The yyfunctions</a></li>				
					<li><a href="#navcompleteexample" class="sec" >A complete Lex Programme</a></li>
					<li><a href="#navdisambiguation" class="sec" >Disambiguation rules</a></li>
					<li><a href="#navpatternmatching" class="sec" >Pattern Matching Using Lex</a></li>
	            <li><a href="#navsimulator" class="sec" >A token simulator program</a></li>
	            <li><a href="#navdfaconstruction" class="sec" >Construction of a DFA from a regular expression</a></li>			
					<li><a href="#navusingthelexicalanalyzer" class="sec" >Using the generated lexical analyzer</a></li>
					<li><a href="#navreferences" class="sec" >References</a></li>				
				
				</ul>
			</menu>
		</aside>		
		
	  	<section class="grid col-three-quarters mq2-col-full">
		
			<div class="grid-wrap">
		   
		   <article  id="navintro" class="grid col-full">
				<h2>Introduction</h2>
				<p>
				LEX is a tool used to generate a lexical analyzer.
				This document is a tutorial for the use of LEX for SIL Compiler development.
			  Technically, LEX translates a set of regular expression specifications (given as input in input_file.l) into a
			   C implementation of a corresponding finite state machine (lex.yy.c).  
			   This C program, when compiled, yields an executable lexical analyzer.              
				</p>
				<img src="img/lex_1.png" style="max-width:70%" /> 
				<p>The source SIL program is fed as the input to the the lexical analyzer which produces  a sequence of tokens as output. 
				 (Tokens are explained below).Conceptually, a lexical analyzer scans a given source SIL program and produces an output of tokens.
				  A token is a single element of the SIL programming language that is recognized by the compiler. 
				  For instance <b>integer, boolean, begin, end, if, while</b> etc. are tokens in SIL.  
              <br>  
              Example:				  
				  <b> “integer”	&nbsp	{return ID_TYPE_INTEGER;} </b>
				  <br>
				  This example demonstrates the specification of  rule in LEX.
				  This rule in this example specifies that the lexical analyzer must return the token named <b> ID_TYPE_INTEGER</b> when the pattern<b> “integer” </b>
				  is found in the input file.
				   A rule in a LEX program comprises of a pattern part (specified by a regular expression) and a corresponding (semantic) action part (a sequence of C statements). 
				   In the above example, <b> “integer”</b> is the pattern and <b>{return ID_TYPE_INTEGER;}</b> is the corresponding action. The statements in the action part will be executed when the pattern is detected in the input.   


				
				</p>
			</article>
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
			
			 <article  id="navstructure" class="grid col-full">
				<h2>The structure of LEX programs</h2>
				<p>
				A LEX program consists of three sections : Declarations, Rules and Auxiliary functions              
				</p>
				<img src="img/lex_2.png" style="max-width:70%" /> 
             <br>				
				<p> <big><b>2.1 Declarations</b></big>  
              <br>  
              The declarations section consists of two parts, regular definitions and auxiliary declarations.
               LEX allows the use of short-hands and extensions to regular expressions for the regular definitions.
               The auxiliary declarations are copied as such by LEX to the output lex.yy.c file.
               <br>
               <b>Example : </b>
               						<div class="syntax"> 
<pre>
%{
	#include<stdio.h>
	int global_variable; 		//Auxiliary declarations 
%}
number 	[0-9]+				//Regular definitions
op 		[-|+|*|/|^|=]	
		
%%
	/* Rules */
%%
	/* Auxiliary functions */
 </pre>
						</div>
						<br>
						A regular definition in LEX is of the form :
							D &nbsp	R  
						<br>
						where <b>D</b> is the  symbol representing the regular expression <b>R</b>. 
						The auxiliary declarations (which are optional) are written in C language and are enclosed within   ' %{ ' and ' %} ' .
						 It is generally used to declare functions, include header files, or define global variables and constants.
				
				</p>
         <p> <big><b>2.2 Rules</b></big> 
         </p>
         <p>
         Rules in a LEX program consists of two parts :         
         </p> 
         <ol>
          <li> The pattern to be matched</li>
          <li> The corresponding action to be executed</li>
         </ol> 
		  <b> Example :</b>
               						<div class="syntax"> 
<pre>

	/* Declarations*/
%%

{number}	{printf(“ number”);}
{op}		{printf(“ operator”);}

%%
	/* Auxiliary functions */

</pre>
						</div>

      <p> The pattern to be matched is specified as a regular expression.<br>Sample Input/Output for the above example: </p>
<div class="syntax"> 
<pre>
I: 234
O:  number

I: *
O:  operator


I: 2+3
O:  number operator number
</pre>
						</div>
						
          <p> LEX obtains the regular expressions of the symbols <b>number</b> and <b>op</b> from 
	          the declarations section and generates code into a function <b>yylex()</b> in the <b>lex.yy.c</b> file.
            This function checks the input stream for the first match to one of the patterns
             specified and executes code in the action part corresponding to the pattern.  </p>
             
             
      <p> <big><b>2.3 Auxiliary functions</b></big> </p>
      <p> LEX generates C code for the rules specified in the Rules section and places this code into a single function called <b>yylex()</b>. 
       (To be discussed in detail later).
        In addition to this LEX generated code, the programmer may wish to add his own code to the <b>lex.yy.c</b> file. 
         The auxiliary functions section allows the programmer to achieve this.</p>   
         
         <b> Example :</b>
            <div class="syntax"> 
<pre>

	/* Declarations */
%%
	/* Rules */
%%

int main()
{
	yylex();
	return 1;
}
</pre>
						</div>
		The C code in the auxiliary section and the declarations in the declaration section are copied as such to the lex.yy.c file.








			</article>	
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
		   
		  </div>
		  <article  id="navvariables" class="grid col-full">
        <h2>The yyvariables</h2>		  
        <p> The following variables are offered by LEX to aid the programmer in designing sophisticated lexical analyzers.
         These variables are accessible in the LEX program and are automatically declared by LEX in lex.yy.c.</p>
         <ul>
        <li><b>yyin</b></li>
        <li><b>yytext</b></li>
        <li><b>yyleng</b></li>          
          </ul>
          <p> <big><b>3.1 &nbspyyin</b></big> </p> 
          <p><b>yyin</b> is a variable of the type <b>FILE*</b> and points to the input file.
            yyin is defined by LEX automatically. 
            If the programmer assigns an input file to <b>yyin</b> in the auxiliary functions section, then <b>yyin</b> is set to point to that file.
            Otherwise LEX assigns <b>yyin</b> to <b>stdin</b>(console input). </p>
          <b>Example :</b>
                      <div class="syntax"> 
<pre>

	/* Declarations */
%%
	/* Rules */
%%
main(int argc, char* argv[]) 
{ 
	if(argc > 1) 
		{	 
			FILE *fp = fopen(argv[1], “r”
			if(fp)
				yyin = fp;
		}
	yylex(); 
	return 1;
}
</pre>
						</div>
						
		<b>Excercise</b>
		<p> In the generated lex.yy.c, the following code segment can be found under the definition of <b>yylex()</b>.</p>	
		                      <div class="syntax"> 
<pre>
if( ! yyin ) 
	yyin = stdin;
</pre>
						</div>	
						
		<p> Try to locate this code segment in the lex.yy.c.
		 What could be the consequences of removing this code segment from <b>lex.yy.c</b> before compiling it for generating the
		  lexical analyzer?
   The above statement indicates that if the programmer does not define <b>yyin</b>, then <b>yylex()</b> by default sets <b>yyin</b>  to the console input.
 Hence, any re-definition for <b>yyin</b> must be made before invoking <b>yylex()</b>.  (This will be explained in detail later).  </p>		
          
          
		  
		  </article>
		
		
		</section>
		
		
		
   		

  		
	   
	   
	</div>










</div>














</body>

</html>