<!doctype html>
<html lang="en">
<head>
<title>LEX</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="css/style.css">
<!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body>
<div class="container">

<header class="center clearfix" id="navtop"> <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
  <nav class="fright">
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="documentation.html" class="navactive">Documentation</a></li>
      <li><a href="uc.html">Code</a></li>
      <li><a href="uc.html">Roadmap</a></li>
    </ul>
  </nav>
</header>


<div class="about center part clearfix">

		<header class="title">
			
			<h3 class="fleft">Contents</h3>			
		</header>
 		
		
    <aside class="column4 mthird">
		
			<menu>
				<ul>
				<li><a href="#navintro" class="sec">Introduction</a></li>
				<li><a href="#navstructure" class="sec">Structure of a LEX Program</a></li>
				<li><a href="#navvariables" class="sec">yyvariables</a></li>
				<li><a href="#navfunctions" class="sec">yyfunctions</a></li>				
				<li><a href="#navcompleteexample" class="sec">A complete LEX Program</a></li>
				<li><a href="#navdisambiguation" class="sec">Disambiguation rules</a></li>
				<li><a href="#navpatternmatching" class="sec">Pattern Matching Using LEX</a></li>
	            		<li><a href="#navsimulator" class="sec">A token simulator program</a></li>
	            		<li><a href="#navdfaconstruction" class="sec">DFA -> regular expression</a><li>			
				<li><a href="#navusingthelexicalanalyzer" class="sec">Using the generated lexical analyzer</a></li>
				<li><a href="#navreferences" class="sec">References</a></li>
				<br>			
				<li><a href="https://github.com/silcnitc/documentation/blob/master/lex/Lex.pdf?raw=true" class="button"> Download as PDF </a></li>	
				</ul>
			</menu>
			
		</aside>		
		
	  	<section class="columnthird content">
		<h1 class="mright">USING LEX</h1>
		
			<div class="grid-wrap">
		   
		   <article id="navintro" class="detail">
				<h2>Introduction</h2>
				<p>
				LEX is a tool used to generate a lexical analyzer.
				This document is a tutorial for the use of LEX for SIL Compiler development.
			  	Technically, LEX translates a set of regular expression specifications (given as input in 					input_file.l) into a C implementation of a corresponding finite state machine (lex.yy.c). This C 					program, when compiled, yields an executable lexical analyzer.              
				</p>
				<img src="img/lex_1.png" style="max-width:70%"> 
				<p>The source SIL program is fed as the input to the the lexical analyzer which produces  a sequence of tokens as output. 
				 (Tokens are explained below).Conceptually, a lexical analyzer scans a given source SIL program and produces an output of tokens.
				  A token is a single element of the SIL programming language that is recognized by the compiler. 
				  For instance <b>integer, boolean, begin, end, if, while</b> etc. are tokens in SIL.  
              <br>  
              Example:				  
				  <b> “integer”	&nbsp;	{return ID_TYPE_INTEGER;} </b>
				  <br>
				  This example demonstrates the specification of  rule in LEX.
				  This rule in this example specifies that the lexical analyzer must return the token named <b> ID_TYPE_INTEGER</b> when the pattern<b> “integer” </b>
				  is found in the input file.
				   A rule in a LEX program comprises of a pattern part (specified by a regular expression) and a corresponding (semantic) action part (a sequence of C statements). 
				   In the above example, <b> “integer”</b> is the pattern and <b>{return ID_TYPE_INTEGER;}</b> is the corresponding action. The statements in the action part will be executed when the pattern is detected in the input.   


				
				</p>
			</article>
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
			</div>
			
			 <article id="navstructure" class="detail">
				<h2>The structure of LEX programs</h2>
				<p>
				A LEX program consists of three sections : Declarations, Rules and Auxiliary functions              
				</p>
				<img src="img/lex_2.png" style="max-width:70%"> 
             <br>				
				<p> <big><b>2.1 Declarations</b></big>  
              <br>  
              The declarations section consists of two parts, regular definitions and auxiliary declarations.
               LEX allows the use of short-hands and extensions to regular expressions for the regular definitions.
               The auxiliary declarations are copied as such by LEX to the output lex.yy.c file.
               <br>
               <b>Example : </b>
               						</p><div class="syntax"> 
<pre>%{
	#include &lt;stdio.h&gt;
	int global_variable; 		//Auxiliary declarations 
%}
number 	[0-9]+				//Regular definitions
op 		[-|+|*|/|^|=]	
		
%%
	/* Rules */
%%
	/* Auxiliary functions */
 </pre>
						</div> <p></p>
						<p><br>
						A regular definition in LEX is of the form :
							D &nbsp;	R  
						<br>
						where <b>D</b> is the  symbol representing the regular expression <b>R</b>. 
						The auxiliary declarations (which are optional) are written in C language and are enclosed within   ' %{ ' and ' %} ' .
						 It is generally used to declare functions, include header files, or define global variables and constants.
				
				</p>
         <p> <big><b>2.2 Rules</b></big> 
         </p>
         <p>
         Rules in a LEX program consists of two parts :         
         </p> 
         
         <ol>
          <li><b> The pattern to be matched</b></li>
          <li> <b> The corresponding action to be executed</b></li>
         </ol> 
		  <b> Example :</b>
               						<div class="syntax"> 
<pre>	/* Declarations*/
%%

{number}	{printf(“ number”);}
{op}		{printf(“ operator”);}

%%
	/* Auxiliary functions */

</pre>
						</div>

      <p> The pattern to be matched is specified as a regular expression.<br>Sample Input/Output for the above example: </p>
<div class="syntax"> 
<pre>I: 234
O:  number

I: *
O:  operator


I: 2+3
O:  number operator number
</pre>
						</div>
						
          <p> LEX obtains the regular expressions of the symbols <b>number</b> and <b>op</b> from 
	          the declarations section and generates code into a function <b>yylex()</b> in the <b>lex.yy.c</b> file.
            This function checks the input stream for the first match to one of the patterns
             specified and executes code in the action part corresponding to the pattern.  </p>
             
             
      <p> <big><b>2.3 Auxiliary functions</b></big> </p>
      <p> LEX generates C code for the rules specified in the Rules section and places this code into a single function called <b>yylex()</b>. 
       (To be discussed in detail later).
        In addition to this LEX generated code, the programmer may wish to add his own code to the <b>lex.yy.c</b> file. 
         The auxiliary functions section allows the programmer to achieve this.</p>   
         
         <b> Example :</b>
            <div id = "navexl0" class="syntax"> 
<pre>	/* Declarations */
%%
	/* Rules */
%%

int main()
{
	yylex();
	return 1;
}
</pre>
						</div>
		<p>The C code in the auxiliary section and the declarations in the declaration section are copied as such to the lex.yy.c file
 </p>
			</article>	
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
			</div>
		   
		  
		  <article id="navvariables" class="detail">
        <h2>The yyvariables</h2>		  
        <p> The following variables are offered by LEX to aid the programmer in designing sophisticated lexical analyzers.
         These variables are accessible in the LEX program and are automatically declared by LEX in lex.yy.c.</p>
         <ul>
        <li><b>yyin</b></li>
        <li><b>yytext</b></li>
        <li><b>yyleng</b></li>          
          </ul>
          <p> <big><b>3.1 &nbsp;yyin</b></big> </p> 
          <p><b>yyin</b> is a variable of the type <b>FILE*</b> and points to the input file.
            yyin is defined by LEX automatically. 
            If the programmer assigns an input file to <b>yyin</b> in the auxiliary functions section, then <b>yyin</b> is set to point to that file.
            Otherwise LEX assigns <b>yyin</b> to <b>stdin</b>(console input). </p>
          <b>Example :</b>
                      <div class="syntax"> 
<pre>	/* Declarations */
%%
	/* Rules */
%%
main(int argc, char* argv[]) 
{ 
	if(argc &gt; 1) 
		{	 
			FILE *fp = fopen(argv[1], “r”
			if(fp)
				yyin = fp;
		}
	yylex(); 
	return 1;
}
</pre>
						</div>
						
		<b>Excercise</b>
		<p> In the generated lex.yy.c, the following code segment can be found under the definition of <b>yylex()</b>.</p>	
		                      <div class="syntax"> 
<pre>if( ! yyin ) 
	yyin = stdin;
</pre>
						</div>	
						
		<p> Try to locate this code segment in the lex.yy.c.
		 What could be the consequences of removing this code segment from <b>lex.yy.c</b> before compiling it for generating the
		  lexical analyzer?
   The above statement indicates that if the programmer does not define <b>yyin</b>, then <b>yylex()</b> by default sets <b>yyin</b>  to the console input.
 Hence, any re-definition for <b>yyin</b> must be made before invoking <b>yylex()</b>.  (This will be explained in detail later).  </p>	
 
 <p> <big><b>3.2 &nbsp;yytext</b></big> </p>
 <p> <b>yytext</b> is of the type <b>char*</b> and it contains the lexeme currently found.
   A lexeme is a sequence of characters in the input stream that matches some pattern in the Rules Section. 
   (In fact, it is the first matching sequence in the input from the position pointed to by <b>yyin</b>.)    

 Each invocation of the function <b>yylex()</b> results in <b>yytext</b> carrying a pointer to the lexeme found in
  the input stream by <b>yylex()</b>.
 The value of <b>yytext</b> will be overwritten after the next <b>yylex()</b> invocation.</p>
 	<b> Example</b>
          
          		                      <div class="syntax"> 
<pre>{%
	#include &lt;stdlib.h&gt;
	#include &lt;stdio.h&gt;
%}
number 	[0-9]+

%%
{number}	{printf("Found : %d",atoi(yytext));}
%%

int main()
{
	yylex();
	return 1;
}
</pre>
						</div>
          
		  
		  <p> In the above example, if a lexeme is found for the pattern defined by <b>number</b> then corresponding action is executed .
		   Consider the following sample i/o,</p>
        <br>
        Sample Input/Output:	
        		                      <div class="syntax"> 
<pre>I: 25
O: Found : 25
</pre>
						</div>		   
		   <p> In this case when <b>yylex()</b> is called, the input is read from the location given by <b>yyin</b> and a string  “25” is found as a match to
		   <b>number</b>.
		    This location of this string in the memory is pointed to by <b>yytext</b>.
		     The corresponding action in the above rule uses a built-in function <b>atoi()</b> to convert the string <b>“25”</b> (of type <b>char*</b>) to the integer <b>25</b> (of the type <b>int</b>) and then prints the result on the screen.
		    Note that the header file <b>“stdlib.h”</b> is called in the auxiliary declarations section in order to invoke <b>atoi()</b> in
		     the actions part of the rule.</p>
		    <br>
		    <b>Exercise:</b>

<p> <i>Suggest a modification in the above example to check whether a number found is even or odd.
</i></p>

<p> <big><b>3.3 &nbsp;yyleng</b></big> </p>
<p> <b>yyleng</b> is a variable of the type <b>int</b> and it stores the length of the lexeme pointed to by <b>yytext</b>.</p>

<b>Example</b>
			<div class="syntax"> 
<pre>/* Declarations */
%%
	/* Rules */
%%
{number}	printf("Number of digits =  %d",yyleng);
</pre>
						</div>
						<b>Sample Input/Output</b>	
						
			<div class="syntax"> 
<pre>I: 1234
O: Number of digits = 4
</pre>
						</div>	   

</article>
		
		<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
			</div>
			
			
 <article id="navfunctions" class="detail">
        <h2>The yyfunctions</h2>	
        <ul>
     <li><b> yylex()</b></li>         
     <li> <b>yywrap()</b></li>
         </ul>
<p> <big><b>4.1 &nbsp;yylex()</b></big> </p>
<p> <b>yylex()</b> is a function of return type <b>int</b>. LEX automatically defines <b>yylex()</b> in lex.yy.c but does not call it.
     The programmer must call <b>yylex()</b> in the Auxiliary functions section of the LEX program.
    LEX generates code for the definition of <b>yylex()</b> according to the rules specified in the Rules section. </p>
    <b> Example :</b>
    	<div class="syntax"> 
<pre>/* Declarations */
%%

{number}	{return atoi(yytext);}

%%

int main()
{
	int num = yylex();
	printf(“Found: %d”,num);
	return 1;
}
</pre>
						</div>	   

<p> Sample Input/Output :</p>

<div class="syntax"> 
<pre>I: 42
O: Found: 42
</pre>
						</div>	 
						
<p> When <b>yylex()</b> is invoked, it reads the input as pointed to by <b>yyin</b> and scans 
through the input looking for a matching pattern. When the input or a part of the input
matches one of the given patterns, <b>yylex()</b> executes the corresponding action associated 
with the pattern as specified in the Rules section. 
In the above example, since there is no explicit definition of
 <b>yyin</b>, the input is taken from the console. If a match is found in the
  input for the pattern number, <b>yylex()</b> executes the corresponding action , i.e.
   return <b>atoi(yytext)</b>. As a result <b>yylex()</b> returns the number matched. The value returned by <b>yylex()</b> is
    stored in the variable <b>num</b>. 
The value stored in this variable is then printed on screen using <b>printf()</b>.</p>	
<p> <b>yylex()</b> continues scanning through the input
 till one of the actions corresponding to a matched pattern 
 executes a <b>return</b> statement or till the end of input (<i>input end-marker</i> ) has
  been encountered. In case of the above example, <b>yylex()</b> terminates immediately after executing the rule because it consists
   of a return statement.
 Note that if none of the actions in the Rules section executes a return statement, <b>yylex()</b>would:</p>		
 <ul>
<li>(In case of an input file) continue scanning for more matching patterns till it finds <b>EOF</b> in the file
  </li>
  <li> (In case of console input) wait for more input through the console</li> 
 
 </ul>	
 <p> In the latter case, since there is no input end-marker, the user will have to input <b>ctrl+d</b>  in the terminal
  to indicate the end of input. As a result, yylex() will terminate.
<br>
 <b> NOTE :</b> 
  If <b>yylex()</b> is called more than once, it simply starts scanning from
   the position in the input file where it had ceased in the previous call.
    </p>		
	<p> 
 <i> <b> Excercise:</b>
 
What would be the outputs of the lexical analyzer generated by 
the example LEX programs under section 3.2 and 4.1 for the following input : 
 </i> <br> 25 <br> 32 <br> 44 <br> 
 <i> Would both the outputs be the same ? If not, explain why.</i>
	</p>
	
	
	<p> <big><b>4.2 &nbsp; yywrap()</b></big> </p>			
	<p>LEX declares the function <b>yywrap()</b> of return type <b>int</b> in lex.yy.c . 
	LEX does not provide any definition for <b>yywrap()</b>. <b>yylex()</b> makes makes a call to <b>yywrap()</b>
	 when it encounters the end of an input. If <b>yywrap()</b> returns zero (indicating <i>false</i>) <b>yylex()</b> assumes
	  there is more input and it continues scanning from the location pointed to by <b>yyin</b>. 
	  If <b>yywrap()</b> returns a non-zero value (indicating true), 
	<b>yylex()</b> terminates the scanning process and returns 0 (i.e. “wraps up”).
	<br>
   	If the programmer wishes to scan more than one input file using the generated lexical analyzer,
	 it can be simply done by setting <b>yyin</b> to a new input file in <b>yywrap()</b>'s definition which returns zero.
	</p>
	<p> As LEX does not define <b>yywrap()</b> in lex.yy.c file but
	 makes a call to it under <b>yylex()</b>,
	  the programmer must define it in the Auxiliary functions section 
	  or provide <b>%option noyywrap</b> in the declarations section. 
	  This options removes the call to yywrap() in the lex.yy.c file. Note that, it is <big><b>mandatory</b> </big>to either define yywrap()
	  or indicate the absence using the <b>%option</b> feature. If not, LEX will flag an error</p>	
	  <b>Example</b>
	  	
						
		<div class="syntax"> 
<pre>	/* Declarations */
%%
	/* Rules */
%%

int yywrap()
{
	FILE *newfile_pointer;
	newfile_pointer = fopen(“input_file_2.l”,”r”);
	if(yyin != newfile_pointer)	
	{
		yyin = newfile_pointer;
		return 0;
	}
	else
		return 1;
}

int main()
{
	yyin=fopen(“input_file.l”,”r”);
	yylex();
	return 1;
}
</pre>
						</div>
						
		<p> When <b>yylex()</b> finishes scanning the first input file, <b>input_file.l</b> <b>yylex()</b> invokes <b>yywrap()</b>. 
		The above definition of <b>yywrap()</b> sets the input file pointer to <b>input_file_2.l</b> and returns 0 .
		 As a result, the scanner continues scanning in <b>input_file_2.l</b> .
 When <b>yylex()</b> calls <b>yywrap()</b> on encountering <b>EOF</b> of <b>input_file_2.l</b>, <b>yywrap()</b> returns 0 and thus <b>yylex()</b> ceases scanning.</p>				

<i><b> Excercise :</b> 
Suggest a modification in the above example LEX program to make the generated lexical analyzer read input
<ul>
<li> Initially from the console and then from a file <b>input_file.l</b></li>
<li> Initially from a file <b>input_file.l</b> and then from the console</li>
<li> Twice from the console</li>

</ul>



</i>

        </article>
        
   <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
	</div>
        <article id="navcompleteexample" class="detail">
        <h2>Even-Odd.l , a complete LEX program</h2>	
        <div class="syntax"> 
<pre>%{ 
/* 
1.Request input of an even and an odd number 
2.indicate input characteristic : Even/Odd [digit_length] 
3.check for input's correctness and print result 
*/ 

#include &lt;stdlib.h&gt;  
#include &lt;stdio.h&gt;

int number_1; 
int number_2; 
%} 


number_sequence [0-9]* 

%% 

{number_sequence}[0|2|4|6|8]		{ 
						printf("Even number [%d]",yyleng); 
						return atoi(yytext); 
					} 

{number_sequence}[1|3|5|7|9]		{ 
						printf("Odd number [%d]",yyleng);	 
						return atoi(yytext); 
					} 
%% 

int yywrap 
{ 
 	return 1; 
} 
 
int main() 
{ 
	printf("\nInput an even number and an odd number\n"); 
 	number_1 = yylex(); 
	number_2 = yylex(); 
	int diff = number_1 - number_2; 
	if(diff%2!=0) 
		printf("\nYour inputs were checked for correctness, \nResult : Correct\n"); 
	else 
		printf("\nYour inputs were checked for correctness, \nResult : 
		       You do not know how to read\n"); 
	return 1; 
}
</pre>
						</div>
              
        
        </article>
        
     <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
	</div>
	
	<article id="navdisambiguation" class="detail">
        <h2>Disambiguation Rules</h2>	
        <p> <b>yylex()</b> uses two important disambiguation rules in selecting the right action to execute
         in case there is more than one pattern that matches a string in the given input: </p>
         <ol>
     <li> Order of occurrence is assigned as the pattern's matching priority.</li>         
     <li>“Longest match” is preferred. 
     </li>
         </ol>
 <b> Example :</b>
 
<div class="syntax"> 
<pre>   “break”                 { return BREAK; }
   [a-zA-Z][a-zA-Z0-9]*    { return IDENTIFIER; }
</pre>
						</div>
	<p> Here, <b>break</b> is matched by both the regular expressions,
	 but <b>break</b> is a keyword and not an identifier hence it is ordered
	    in such a manner that LEX uses its first disambiguation rule to execute <b>return BREAK</b>;</p>
     <b> Example :</b>
   <div class="syntax"> 
<pre>/* Declarations section */
%%

“-”		{return MINUS;}
“--”		{return DECREMENT;}

%%
	/* Auxiliary functions */
</pre>
						</div>  
						<p> Assume that the function calling yylex() prints the name of the token.</p>       
         <b>  Sample Input/Output :</b>
            <div class="syntax"> 
<pre>I: -
O: MINUS
&lt;
I: --
O: DECREMENT

I: ---
O: DECREMENT MINUS
</pre>
						</div>
						
						<p>Note that, in case of an<b> ---</b> input to the lexical analyzer, <b>yylex()</b> does not return two <b>MINUS</b> tokens,
						 but instead returns a <b>DECREMENT</b> token, by the second disambiguation rule.</p>
         
	
	</article>
	 <div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top ↑</a>
	</div>
		<article id="navpatternmatching" class="detail">
        <h2>Pattern matching using LEX</h2>
	<p> Conceptually, LEX constructs a finite state machine to recognize all the regular expression patterns specified
	 in the LEX program file.  The code written by the programmer in the action part is executed when the machine is in accept state. 
	 The lex.yy.c program stores information about the finite state machine in the form of a decision table (transition table).   
 	A <b>transition(current_state,input_char)</b> function is used to access the decision table.
 	 LEX makes it's decision table visible if we compile the program with the -T flag. 
 	 The finite state machine used by LEX is deterministic finite state automation.  The lex.yy.c simulates the DFA. </p>
	</article>	
				 <div class="up grid col-one-third" style="float:right">
		      	<a href="#navtop" title="Go back up"> top ↑</a>
	          </div>
			
		<article id="navsimulator" class="detail">
        <h2>A token simulator program</h2>
			          <div class="syntax"> 
<pre>%{ 
/* Scan and return a token for identifiers of the format : 				
             (string)(number) 
	Note : strings are not case sensitive 
	examples : a0 , A1 , ab2 , AB4 , aBc5 
*/ 
#include<stdio.h> 

#define ID 1	//Identifier token 
#define ER 2	//Error token 

%} 
low_case [a-z] 
upp_case [A-Z] 
number	[0-9] 

%option noyywrap 

%% 
({low_case}|{upp_case})({low_case}|{upp_case})*({number})
								   return ID; 
(.)*								return ER; 

%% 
int main() 
{ 
	int token = yylex(); 
	if(token==ID) 
		printf("Acceptable\n"); 
	else if(token==ER) 
		printf("Unacceptable\n"); 
	return 1; 
} 
</stdio.h></pre>
						</div>
						
						<p>In this program, the main() function obtains the tokens returned by <b>yylex()</b> and checks if the input contains a valid identifier.
						 </p>
			
			<b> Sample Input/Output : </b>
			<div class="syntax"> 
<pre>I: Var9
O: Acceptable
</pre>
						</div>
						<p> When <b>Var9</b> is provided as the input, the DFA constructed by LEX accepts the string,
						 and the corresponding action <b>return ID</b> executed.
						  As a result yylex() returns the token <b>ID</b>, and the main() function prints <b>Acceptable</b> on the screen. </p>
   
         
   
   </article>		
   
    <div class="up grid col-one-third" style="float:right">
		      	<a href="#navtop" title="Go back up"> top ↑</a>
	          </div>
	          
	   <article id="navdfaconstruction" class="detail">
        <h2>Construction of a DFA from a regular expression</h2>
	      <p> The construction of a DFA from a regular expression takes place in two steps.</p>    
	      <ul>
          <li>Constructing a syntax tree from the regular expression
           </li>	
           <li> Converting the syntax tree into a DFA </li>     
           
       	          </ul>
       	          
       <b><big> 9.1	The intermediate syntax tree</big></b>	  
       <p>  Consider the first rule in the token simulator program in section 8.
        It consists of the following regular expression :</p>        
           <b>({low_case}|{upp_case})({low_case}|{upp_case})*({number})</b> 
           <p>For convenience in representation , let it be represented by :</p>
           <b> ( a | A ) ( a | A )* (N)</b>    	   
           <p>where, 'a' represents <b>{low_case}</b>, 'A' represents <b>{upp_case}</b> and 'N' represents <b>{number}</b>. 
             The syntax tree constructed for the above regular expression would look like :	</p>  
             <img src="img/lex_5.png" style="max-width:70%">   
             <p> In the above figure <b> º </b>represents the <b>'cat'</b> (concatenation) operator, 
             <b>*</b> represents the 'star' operator (a unary operator) and <b>|</b> represents the 
              'or' operator. In the syntax tree the inner nodes are operators
               while the leaves are the operands.
               The subscript assigned to every leaf is called the position of the leaf.
                The position of a leaf plays a vital role in the process of constructing states for the DFA. 
             </p> 
             
             <p> NOTE:
             <br>
      This syntax tree is an intermediate data structure.
     There will be no traces of this in lex.yy.c file, because it is only used in the construction of the DFA.</p> 
     
     <b><big> 9.2	The intermediate syntax tree</big></b>	
      <p>Constructing the DFA involves two steps:</p>
       <ul> 
      <li>Constructing the set of states of the DFA</li>       
        <li>Constructing all the possible transitions made by the DFA from one state to another on different inputs. </li>       
       </ul>
	          <p> The language represented by the regular expression ( a | A ) ( a | A )* (N),
	           can only possibly start with an 'a' or 'A'. From the syntax tree we may infer that these could only correspond to positions 1 or 2 . Let the set of these positions {1,2} be the start state of the DFA.
	           For convenience it has been named as state I.</p>
	           <p> Consider the position 1 ('a'), it could be followed by either of the positions 3,4 or 5. 
	           Let this be a new state {3,4,5} represented by II. 
	           The position 2 ('A') could be possibly followed by either of the positions 3,4 or 5.
	            But a new state is not required as {3,4,5} has already been represented by II. 
	            Similarly the positions 3 and 4 could be followed by the position 3 or 4 or 5.
	             If followed by 5, the DFA must accept and terminate (syntax tree ends at position 5). 
	             Hence let the final (accept) state be III. 
Thus, the transitions maybe formulated as :</p>

    <img src="img/lex_3.jpeg" style="max-width:70%">
    <br> 
    
	   <b><big> 9.3	The intermediate syntax tree</big></b>
	   <p> The DFA obtained for the above syntax tree would look like :</p>
	   <img src="img/lex_4.png" style="max-width:70%">
	          <p> This DFA represents the regular expression provided as a specification 
	          (i.e. pattern to be matched) in the first rule of the token
	           simulator program in section 9. When the DFA is in the final state i.e. III, 
	           then the corresponding action is executed as instructed in the lex.yy.c file.
	           The constructed DFA is simulated using a simulation algorithm. </p>
	           <br>
	           
	           
	           <b><big> 9.4	The DFA simulation algorithm</big></b>
	           <p> The working of the constructed DFA is simulated using the following algorithm.</p>
	           			<div class="syntax"> 
<pre>DFA_simulator()
	current_state = start_state
	c = get_next_char()
	while(c != EOF)
		current_sate = transition(current_state , c)
 		c = get_next_char()
		if(current_state ∈ Final_states)
			/*ACCEPT*/
		else
			/*REJECT*/

</pre>
						</div>
	           <p> The information about all the transitions made by the DFA 
	           can be obtained from the decision
	            table (generally a two dimensional matrix) through the <b>transition()</b> function. 
              </p>
	           
	          
	       </article>
	        <div class="up grid col-one-third" style="float:right">
		      	<a href="#navtop" title="Go back up"> top ↑</a>
	          </div>
	          
	          
	           <article id="navusingthelexicalanalyzer" class="detail">
        <h2>Using the generated lexical analyzer</h2>
	          <p> The generated lex.yy.c file is the code for the scanner. 
	          This is compiled using a C compiler and the generated object file (the executable scanner) 
	          is executed. LEX is just a tool which helps generate a smart scanner in C. 
	The lexical analyzer only checks for recognizable pattern sequences in the source program
	 and produces an output of tokens (fed to the parser) , it cannot be used to check for syntax.
	  Syntax analysis is done by the parser. The parser is built using YACC , a parser generator.
	   YACC obtains the tokens from LEX through yylex() and the associated attributes from yylval, 
	    which it uses for parsing and rest of the the compilation process. In this case, the programmer
	     need not call yylex() in the LEX program, it is automatically called by YACC to read the tokens.
	      The parser , when given an input source program obtains all the tokens from the lexical analyzer
	       and checks for correctness of the syntax. Hence, the next step towards compiling a given source program would be to build a parser.   
             </p>
	          </article>
	          
	          <div class="up grid col-one-third" style="float:right">
		      	<a href="#navtop" title="Go back up"> top ↑</a>
	          </div>
	          
	      <article id="navreferences" class="detail">
        <h2>References</h2>
	    <p> For further details on the topics covered in this document, the reader may refer to the following :</p>
	    <ul>
	    <li> Compilers : Principles,Techniques and Tools by Alfred V.Aho, Monica S. Lam, Ravi Sethi and Jeffrey D.Ulman .</li>  
     	    <li>Modern Compiler Implementation in C by Andrew W.Appel</li>
	    <li> Flex &amp; Bison by John Levine</li>
	    <li> http://dinosaur.compilertools.net/</li>
	    
	    </ul>

    	    <div class="up grid col-one-third" style="float:right">
		      	<a href="#navtop" title="Go back up"> top ↑</a>
	          </div>
	    
	    
	     </article>    	
			</div>
		</section>
		

	</div>

</div>
</body>
<!-- Javascript - jQuery 
<script src="http://code.jquery.com/jquery.min.js"></script>-->
<script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>

<!--[if (gte IE 6)&(lte IE 8)]>
<script src="js/selectivizr.js"></script>
<![endif]-->

<script src="js/scripts.js"></script>

</html>
