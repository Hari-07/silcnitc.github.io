<!Doctype html>
<html lang="en">
    <head>
        <title>OExpL Runtime Data Structures</title>
        <meta charset="UTF-8">
        <!--<link rel="stylesheet" href="css/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/style_new.css">
        <link rel="stylesheet" href="js/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4.css"><div id="gist28627206" class="gist">
        <link rel="stylesheet" href="js/embed-cbe5b40fa72b0964f90d4919c2da8f8f94d7c9f6c2aa49c07f6fa3.css"><div id="gist28627206" class="gist">
        <script src="js/jquery-1.12.1.min.js" charset="utf-8"></script>
        <script src="js/bootstrap.min.js" charset="utf-8"></script>
        <script src="js/sticky_sidebar.js" charset="utf-8"></script>

    </head>
    <div class="container">
        <header id="navtop">
            <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
            <nav class="fright">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
        			    <li><a href="help.html">Help</a></li>
        			    <li><a href="roadmap.html">Roadmap</a></li>
        			    <li><a href="documentation.html" class="navactive">Documentation</a></li>
                </ul>
            </nav>
        </header>
        <body>
        <div class="Services-page main grid-wrap">
            <header class="grid col-full">
                <hr/>
                <p class="fleft">Runtime Data Structures for OExpL</p>
                <br>
                <br>
            </header>
            <aside class="grid col-one-quarter mq2-col-full sticky_sidebar">
              <menu>
                <ul>
                  <li><a class="sec" href="#nav-virtual-function-table">Virtual Function Table</a></li>
                  <li><a class="sec" href="#nav-illustration">Illustration</a></li>
                  <li><a class="sec" href="#nav-importance">Run Time Binding</a></li>
                <!--  <li><a class="sec" href="#nav-resolve">Resolving Strategy using Virtual Function Table</a></li> -->
              </ul>
              </menu>
              <!-- <a class="button" href="">Download as PDF</a> -->
            </aside>
            <section class="grid col-three-quarters mq2-col-full">
                <div class="grid-wrap">
                  <article class="grid col-full" id="nav-virtual-function-table">
                      <h2>Virtual Function Table</h2>
                      <p>

                        <b>Virtual Function Table</b> is a run time data structure that is used to resolve at run time the
                        call addresses of methods in a class.  Such mechanism (or other table schemes) needs to be
                        implemented by compilers for languages that support <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">
                        inheritance</a>, <a href="https://en.wikipedia.org/wiki/Subtyping">subtype Polymorphism</a> and <a href="https://en.wikipedia.org/wiki/Method_overriding">method over-riding</a>.
                        A run time virtual function table is maintained in the memory for each class.  The compiler generates code
                        to initialize the table such that each function that can be invoked from the class has an entry
                        in the table.  For each function defined or inherited by a class, the table will contain the call address of
                        the function in the code region of memory. Thus, if a function is inherited by a class from its parent and is
                        not over-ridden by the class, the call address stored (will be same in the virtual function tables of both the classes) will be that of the function defined in the parent class.
                      </p>
                      <p>
                        The OExpL compiler maintains a virtual function table of eight words for each class.  Hence, a class can have at most eight
                        member functions.  The i-th entry in the table holds the address of the i-th function of the class (identified by the
                        field <b>Funcposition</b> in the <a href="http://silcnitc.github.io/oexpl-data-structures.html">class table</a> - see Memberfunclist).
                         While generating code, if there is a call to a function within a class, the compiler simply translates the call to "CALL [address]",
                          where address is obtained from the corresponding virtual function table.
                      </p>
                      <p>
                         A simple way to place the virtual function table is to use the initial part of the stack region (starting at memory
                         address 4096), ahead of global variables. This is suggested because the compilation of classes will be
                         finished before compiling the global declarations.  In this scheme, the class table of the class defined
                         first in the program will be stored in the region 4096-4103, the second in 4104-4111 and so on.
                      </p>

                      <p>
                        When the compiler encounters the declaration of a variable of a class, it allocates <b>two words of storage</b> for the variable
                        (unlike other variable, where only one word of storage is allocated).
                        The first word is used to store the address of the memory area allocated in the heap for the class (eight words).
                        Space for member fields is allocated in the heap exactly as done with user defined types.
                        We will call this word the <b>member field pointer</b>.   The second word is used to store the address a virtual function table.
                        We will call this word the <b>virtual function table pointer</b>.
                      </p>

                      <p>
                      <b>  The key point to note here is that the virtual function pointer of a variable need not always
point to the virtual function table of the class of the variable.  This is because a variable of a parent class can hold a reference to an object of any of its descendant classes.  In such cases, the virtual function pointer will hold the address of the descendant class.
    </b>
                      </p>


                      <p>
                        Hence, an assignment of a variable (of one class) to another variable (of the same class or an ancestor class) results in transfer of the contents of both the pointers of one variable to the corresponding pointers of the other.   The <i>new</i> function sets the virtual function table pointer to the address of the virtual function table of the class specified as the argument to the new function.  A little thought would reveal that this implementation will yield the correct execution semantics.
                      </p>

                      <p> A detailed illustration follows.</p>

                    </article>
                    <article class="grid col-full" id="nav-illustration">
                        <h2>Illustration</h2>

                          <script src="../js/71e1ad248ff055d56e110287d80d0b0a.js"></script>

                          <br>

                            <ol>
                            <li>

                          <p>

                             Storage for virtual function tables start at 4096 in the stack.  Eight consecutive words are allocated for storing the virtual function table of each class. Each word of virtual function table stores the call address of the corresponding function in the class. Thus, a class can contain atmost eight methods. Virtual function tables are stored in the order in which they are declared in the program. As noted earlier, we will allocate the space for global declarations after virtual function tables are allocated.
                           </p>

                           <p>
                              By using the <i>class_index</i> field of the <a href="http://silcnitc.github.io/oexpl-data-structures.html">class_table</a> entry, the starting address of the virtual function table for that particular class can be computed using the formula  <b>4096 + (class index * 8)</b>.  The class defined first will have class index zero, the next will have one and so on.
                           </p>

                           </li>

                           <br>



                             <li>

                               <p>

                             When the declaration of each method is found (in a class) a new label is generated for the function and the label is stored in the <a href="http://silcnitc.github.io/oexpl-data-structures.html">class table entry</a> for the function at compile time.   The compiler also must generate code to store these labels into the virtual function table entry of the function in the corresponding class. (Strictly speaking, an integer value called the  "psedudo-address" for the function is stored in the <i>flabel</i> field of the <i>Memberfunclist</i>  entry of the function. When code is generated, for functions with <i>flabel</i>
values 0,1,2,3, etc., the actual labels placed could be F0,F1,F2,F3 etc to make them more human readable.)     <b>The index of the function in the <a href="http://silcnitc.github.io/oexpl-data-structures.html">class table</a> (funcposition) and the virtual function table is maintained to be the same.</b>

                           </p>

                           <p> [Note:  It is sufficient to place labels, and not addresses in the virtual function table, as the <a href="http://silcnitc.github.io/label-translation.html">label translation phase</a> will take care of translating labels to addresses]. </p>

                           <p>
                             In the example given, the function f1 in class A has  funcposition 0 and say flabel F0 (we identify flabel 0 with F0) and the function f2 in class A gets a funcposition 1 and say flabel F1 (we identify flabel 1 with F1). The member function list of class A looks as shown in the below figure :


                                <br><a href="../img/virtual_function_table_3.png"> <img src="../img/virtual_function_table_3.png" class="center"></img></a>
                              <br />
                              The virtual function table of class A looks as shown in the figure below. It is constructed using member function list of class A which is shown in the figure above.
                              <!--Similarly for <i>rollno,aerage,findaverage(linkedlist marks)</i>, symbol table entries are formed and installed.-->

                            <br><a href="../img/virtual_function_table_1.png">  <img src="../img/virtual_function_table_1.png" class="center"></img></a>
                            <br />As mentioned earlier, all the labels of the functions will be replaced with addresses during <a href="http://silcnitc.github.io/label-translation.html">label translation phase</a>.
                          </p>
                          </li>

                          <br>
                          <li>
                            <!--
                        <p>
                           For every method declaration, a new label is alloted.
                           In class A, the function f1 gets an index 0 an say label f1 and
                            <br/>  the function f2 gets an index 1 and say a label f2.
                        </p>
                        <p>


                            Following is how virtual function table looks in the stack when <i>A</i> class is installed.<br>-->
                            <!--Similarly for <i>rollno,average,findaverage(linkedlist marks)</i>, symbol table entries are formed and installed.-->

                            <p>
                              Class B extends class A and over-rides f1().  Class B further contains the newly defined method f3().   When a class extends another class, all the member fields and methods of the parent class are inherited by the derived class, unless over-ridden by a new definition.  Here, B over-rides the method f1() of class A.  OExpL specification stipulates that the signatures of the over-ridden method in B must match exactly with the signature of the original definition in the parent class.
                            </p>

                            <p>
                               All the member fields and methods of class A are inherited by class B initially.  However, since the method f1() is overridden by Class B, a new label will be allocated, for the function f1() in class B.   Accordingly, we will update <i>Memberfunclist</i> entry of the method f1() in class B by a new <i>flabel</i> value. Similarly, the <i>Memberfunclist</i> entries for class C will be constructed. <br><br>The final class tables and corresponding member function lists are shown in the figure below.
                            </p>


<!--
                            In class B, there are two methods f1() and f3() and it is extending class A. When a class extends other class,
                            all the member fields and methods of the parent class are inherited by the derived class. Suppose as in this example,
                            if the method signatures of the parent class and the derived class match, then method overriding occurs.
                            <br />
                            <a href="https://en.wikipedia.org/wiki/Method_overriding">Method Overriding</a> means the definition of the method that belongs to
                            parent class is replaced by the definition of the method which is already present in the derived class.
                            Here, f1() method of class B overrides the f1() method of class A.
                            Let us see how the process of method overriding occurs, how the member function list is updated for the derived class.
                            This is demonstrated using the classes B and A of this OExpL program.

                            Here, class B is extending class A.
                            So, all the member fields and methods of class A is inherited by class B.

                           So, now the member function list looks as shown in the figure below.

                            <img />

                            Here method f1() derived from class A, will be overridden by the method f1() of class B.
                            As stated above, a new label will be alloted, for the f1() method of class B.
                            Now, we need to update the member func list entry of the f1() method in class B, by new flabel given to the method f1() of class B.
                            Similarly, the member func list for class C will be constructed.
                            The final class tables and corresponding member function lists are shown in the figure below.
                            <br /><br />-->
                            <br><a href="../img/virtual_function_table_4.png"> <img src="../img/virtual_function_table_4.png" class="center"></img></a>
                          <br /><br><br>
                            <p> * Overridden labels are marked in red </p>
                          <p>
  The corresponding virtual function tables of all the classes are shown in the figure given below :
  </p>
                            <br />
                            <br><a href="../img/virtual_function_table_2.png">  <img src="../img/virtual_function_table_2.png" class="center"></img></a>
                            <br />

                            <p> * Overridden labels are marked in red </p>
                        </li>


                        </ol>
                    </article>

                    <article class="grid col-full" id="nav-importance">
                      <h2>Run Time Binding</h2>
                      <script src="../js/9fab0ed1079cbf0ebdae2916b4272929.js"></script>
                      From the above code, the calling of the function depends on the input value n.
                      If n < 0, the method in the class A is called.
                      If n = 0, the method in the class B is called.
                      If n > 0, the method in the class C is called.
                      So, Depending on the value of n, the obj gets the address.
                      Even though the three methods which are overridden has the same name f1(), the labels will be different.
                      The statement CALL F_LABEL could not be generated, because at the compile time we cannot decide the flabel value.
                      The label of the function cannot be decided.
                      flabel should be determined according to the object the class variable gets.
                  <!--  </article>

                    <article class="grid col-full" id="nav-resolve"> -->
                      <h2>Resolving Strategy</h2>

                      For every class variable, generally one block of memory in stack is allocated for storing the heap address.
                      But with the introduction of subtyping, we face the problem of resolution of which method to call as shown in the example
                      above.
                      So, now to resolve this we use virtual function table and every class variable will be allocated two blocks of memory.
                      One block is used to store the heap address and the other block is used to store the starting address of the virtual function table.

                      <h4> During Compile Time</h4>

                      In the above example, when compiler reaches the statement, <b>obj.f1()</b>, it checks the type of obj, which means
                      to which class the <b>obj</b> belongs to. Then it gets the member function list of the class of that object and checks if there
                      is any method with name <b>f1</b>. If it finds a method, it proceeds with the compilation. If it doesn't find, then it is a
                      compilation error.

                      When it encounters the statement, <b> obj = new(A);</b>, the second block of object is set.
                      The second block of the object is to be set with the starting address of virtual function table of a class.
                      So, here,
                      (4096 + class_index * 8) is the starting address of virtual function table of the required class. The class_index is that of the class
                      that is present in new. So, for <b>obj = new(A);</b> 4096 is stored because class index of A is 0. Similarly, for class B, 5004 is stored.
                      For class C, 5012 is stored.
                      When the compiler encounters a call statement, from the second block of A we get start address of virtual function table,
                      and funcposition is obtained from the member function table of class to which this object belongs to.
                      Both are added and the value present in that address(flabel) is stored in a register.
                      Then a call to the register is made.

                      <h4>During Run Time</h4>

                      if '( n < 0)' then the two words of obj is : <br />
                      <a href="../img/virtual_function_table_5.png">  <img src="../img/virtual_function_table_5.png"></img></a><br />
                      if '(n = 0)' then the two words of obj is : <br />
                      <a href="../img/virtual_function_table_6.png">  <img src="../img/virtual_function_table_6.png"></img></a><br />
                      if '(n > 0)' then the two words of obj is : <br />
                      <a href="../img/virtual_function_table_7.png">  <img src="../img/virtual_function_table_7.png"></img></a><br />

                      During run time, only one if will be executed. That means by the completion of if,else block, required values are set,
                      and the call to the required function is made.


                    </article>


                  </div>
              </section>

           </div>
           </div>
           <footer class="center part clearfix">
           <ul class="grid col-one-third social">
               <li><a href="http://github.com/silcnitc">Github</a></li>
           </ul>
           <div class="grid col-one-third" style="color:black;">
               <p style="font-weight: bold;">Contributed By : <a href="#">J.Ritesh</a> <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="#">J.Phani Koushik</a><br> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="#">M.Jaya Prakash</a>
               </p>
           </div>
           <nav class="grid col-one-third ">
               <ul >
                   <li><a href="index.html">Home</a></li>
                   <li><a href="about.html">About</a></li>
                   <!-- <li><a href="uc.html">Contact</a></li> -->
               </ul>
           </nav>
           <br>
           </footer>
           <script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>
           <script src="js/scripts.js"></script>
           </body>
           </html>
