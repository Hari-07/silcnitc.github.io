<!Doctype html>
<html lang="en">
    <head>
        <title>Roadmap</title>
        <meta charset="UTF-8">
        <!--<link rel="stylesheet" href="css/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/style_new.css">
        <script src="js/jquery-1.12.1.min.js" charset="utf-8"></script>
        <link rel="stylesheet" href="js/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4.css"><div id="gist28627206" class="gist">
        <link rel="stylesheet" href="js/embed-cbe5b40fa72b0964f90d4919c2da8f8f94d7c9f6c2aa49c07f6fa3.css"><div id="gist28627206" class="gist">
    </head>
    <div class="container">
        <header id="navtop">
            <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
            <nav class="fright">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
                        <li><a href="#">Help</a></li>
                        <li><a href="#">Code</a></li>
                        <li><a href="roadmap.html" class="navactive">Roadmap</a></li>
                        <li><a href="documentation.html">Documentation</a></li>
                </ul>
            </nav>
        </header>
        <div class="Services-page main grid-wrap">
            <header class="grid col-full">
                <hr/>
                <p class="fleft">ROADMAP</p>
                <br>
                <br>
                <!--<a class="button" href="">Download as PDF</a>-->
            </header>
            <aside class="grid col-one-quarter mq2-col-full">
                <menu>
                    <ul>
                        <li class="sec"><a href="#nav-stage0">0. Installation</a> </li>
                        <li class="sec"><a href="#nav-stage1">1. CodeGeneration for Arithmetic Expressions</a></li>
                        <li class="sec"><a href="#nav-stage2">2. Introduction to static storage allocation</a></li>
                        <li class="sec"><a href="#nav-stage3">3. Adding Flow Control Statements</a></li>
                    </ul>
                </menu>
            </aside>
            <body>
            <section class="grid col-three-quarters mq2-col-full">
                <div class="grid-wrap">
                    <article class="grid col-full">
                        <h2>Using the Roadmap</h2>
                        <p>
                            This roadmap is divided into several stages, to be done in sequential order. Incrementally you will build a compiler for the ExpL language according to its specification. Links are provided for background reading material wherever appropriate. It will be assumed that you have background in C programming, Data Structures and Principles of Computer Organization.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage0">
                        <h2>Stage 0 : Installation and Preparation</h2>
                        <p>
                            <b>Pre-requisites</b>: NIL<br>
                        	In this stage, you will download and familiarize yourself with the simulation package and learn the compiler design software tools LEX and YACC.  Follow the instructions below.
                        </p>
                        <p>
                            <ul>
                                <li id="otis">1.  Install the LEX, YACC and the XSM simulator package.  Follow the instructions <a href="install.html" target="_blank">here</a></li>.
                            </ul>
                        </p>
                        <p>
                            You need to learn two software tools - YACC and LEX which you will use in the project. These tools are somewhat
                            sophisticated. Fortunately, understanding what is enough for the purpose of our compiler project is not very difficult. The following tutorials will help you through this process.
                        </p>
                        <p>
                            If you are not already familiar with the tools LEX and YACC do the following:<br>
                            <ul>
                                <li id="otis">2.  Complete the <a href="lex.html" target="_blank">LEX tutorial</a>.</li>
                                <li id="otis">3.  Complete the <a href="yacc.html" target="_blank">YACC tutorial</a>.</li>
                                <li id="otis">4.  Complete the <a href="ywl.html" target="_blank">Using YACC with LEX tutorial</a>.</li>
                            </ul>
                        </p>
                        <p>
                            The next step is to understand the target machine envionment. You must carefully go through the following tutorial
                            before proceeding to the next stage of this roadmap.
                        </p>
                        <p>
                            5.  Complete the <a href="xsm-environment-tut.html">XSM execution environment tutorial</a>.
                        </p>
                        <p>
                            With this, you are ready with all the required pre-requisites to proceed further in this roadmap.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage1">
                        <h2>Stage 1 : Code generation for Arithmetic Expressions</h2>
                        <p>                        
                            <b>Prerequisites</b>:<br/>
                            <ul>
                                <li id="otis">1.  You must be comfortable with LEX and YACC.  ( If you are not, you must first do <a href="lex.html" target="_blank">LEX</a> tutorial, <a href="yacc.html" target="_blank">YACC</a> Tutorial and <a href="ywl.html" target="_blank">Using Lex with Yacc</a> tutorials.)</li>   
                                <li id="otis">2.  You must have completed the <a href="xsm-environment-tut.html" target="_blank">XSM environment tutorial</a> before staring this stage.</li>
                            </ul>
                        </p>
                        <p>                        
                            <b>Learning Objectives</b>:<br/>
                            <p>In this stage, you will:</p>  
                            <ul>
                            <li id="otis">1.  Parse an input  arithmetic expression and create and expression tree using YACC and LEX.</li>
                            <li id="otis">2.  Recursively traverse the tree and generate assembly language code.  You learn to solve the <i>register allocation problem</i> enroute.</li>
                            </ul>
                        </p>
                        <p>
                            The strategy of the roadmap is to help you build the compiler in stages.  We start here by building a compiler for simple arithmetic expressions. In subsequent stages, we will add more features of the language by one, learning the relevant theoretical concepts along the way. 
                        </p>
                        <p>
                            In this stage, you will implement a very simple compiler that can take an arithmetic expression as input (from some input file)  and generate a target executable file containing XSM instructions to evaluate the expression and output the result.  
                        </p>
                        <p>
                            We assume that you have implemented the library routine for handling console output, which you were asked to do in the <a href="xsm-environment-tut.html" target="_blank">XSM execution environment tutorial</a>.  
                        </p>
                        <p>                            
                            Consider arithmetic expressions with the following syntax.
                            <div class="syntax">
                                E :  E + E | (E) | NUM  
                            </div>
                            Where the <a href="lex.html#navyytext" target="_blank">lexeme</a> <b>NUM</b> correspond to integers.  Assume left <a href="yacc.html#associativity" target="_blank">associativity</a>  for '+'. Thus, the <a href="lex.html#token" target="_blank">tokens</a> relevant are NUM and +. The attribute value associated with a number is the number read.  Assume that the input file is passed as argument to the main() function in YACC.  
                        </p>
                        <p>
                            The lexer must pack the attribute into a tree node of the following structure:
                           <div class="syntax">         
                            typedef struct tnode{<br>
                            &emsp;char *op;           //indicates the name of the opertor for a non leaf node<br>
                            &emsp;struct tnode *left,*right;      //left and right branches<br>
                            }tnode;<br>
                            <br>
                            #define YYSTYPE tnode*
                            </div>
                      <!--       Specifiy YYSTACK type:  /* Give  tree node definition just sufficient for this purpose, explaining why each field is required */ -->   
                            Since the semantics actions in the parser must build the tree, the following function must be written:
                            <div class="syntax">
                            /*Make a leaf tnode and set the value of val field*/<br/>
                            struct tnode* makeLeafNode(int n);<br/>
                            <br/>
                            /*Make a tnode with operator, left and right branches set*/<br/>
                            struct tnode* makeOperatorNode(char op,struct tnode *l,struct tnode *r);
                            </div>  
                            <!-- TreeCreate(...)  function to create tree – Again, just enough for the purpose, explaining arguments.   -->
                        </p>
                        <p>
                            <b>Task 1</b>:  Build the expression tree for the given input.<br>
                            <b>Exercise 1</b>:  Output the prefix and postfix forms of the expression from the tree.<br>
                        </p>

                        <p>
                            (Note:  You would have already completed this task if you have done the <a href="ywl.html" target="_blank"> Using Yacc With Lex tutorial </a>).
                        </p>
                        <p>    
                            Now, comes the next task - to generate assembly language program equivalent for the expression and write it out into an executable file in the XEXE format.  Once this is done, you can use the simulator to load the XEXE file into the memory of the XSM machine and execute it as outlined in the <a href="xsm-environment-tut.html" target="_blank"> XSM run time environment tutorial</a>.
                        </p>

                        <p>
                            To do this, one needs to know the following:<br>
                            <ul>
                                <li id="otis">1. The machine model and the <a href="abi.html#nav-XSM-instruction-set" target="_blank">instruction set</a> of the target machine.</li>
                                
                                <li id="otis">2. Format of the <a href="abi.html#nav-XEXE-executable-file-format" target="_blank"> executable file</a>.</li>
                                
                                <li id="otis">3. You need to know the address in the memory (in the target machine) where each instruction you generate will be loaded (by the OS loader). This is because program control instructions like JMP, CALL etc.,  requires specification of the jump address. <br>
                                
                                As already outlined in the <a href="xsm-environment-tut.html" target="_blank"> XSM run time environment tutorial</a>, the header will be loaded into addresses 2048-2055. The first instruction generated by you will be loaded to the address 2056. Each XSM instruction occupies 2 memory words. Hence, the next instruction will be loaded at address 2058 and so on. The entry point field of the header must contain the address of the first instruction to be fetched and executed.</li>

                                <li id="otis">4. You need fix the memory addresses where variables and other data is stored. For example, for each variable in the program, the compiler will have to allocate storage space in memory. The ABI stipulates that the region for this is the <a href="abi.html#nav-virtual-address-space-model" target="_blank"> stack region</a>. Thus each variable must be stored in some address between 4096 and 5119.</li>

                                <li id="otis">5. Since XSM machine stipulates that arithmetic and logic instructions can be done only when operands are loaded into machine registers, we need to load the contents of variables/constants in the program into the machine registers before processing them. This brings in the problem of register allocation. The XSM machine makes available 20 registers (R0-R19) for the compiler.</li>   
                            </ul>
                        </p>
                        <p>
                            Of the above, the XSM execution environment tutorial has already explained (1) and (2). Evaluation of expressions do not involve either storage allocation or program control transfer (JMP). Hence, we will not take up (3) and (4) at this stage. However, we need to solve (5) now. 
                        </p>
                        <p><h3>What must be the evaluation strategy?</h3></p>
                        <p>
                            Let us take an example:<br><br>

                            If you are given a two node expression tree as shown below corresponding to the expression (3+2):<br>
                        </p>
                        <p>
                            <img src="img/tree1.png">
                        </p>
                        <p>
                            The evaluation strategy will be:
                            <ul>
                                <li id="otis">1.  Store 3 in a register – say R0.</li>
                                <li id="otis">2.  Store 2 in a register – say R1.</li>
                                <li id="otis">3.  ADD R0, R1.</li>
                            </ul>
                        </p>
                        <p>               
                            The result will be stored in R0 and is sufficient for us. To generate code for the above tasks and write it into a target_file, you must write code as:  

                        <div class="syntax">
                            fprintf(target_file, "MOV R0, 3");<br>
                            fprintf(target_file, "MOV R1, 2");<br>
                            fprintf(target_file, "ADD R0, R1");<br>
                        </div>

                            However, life becomes complicated if we have an expression like (3+2)+(5+6) resulting in the following tree.
                        </p>
                        <p>
                            <img src="img/tree2.png">
                        </p>
                        <p>
                            Of course, we can “hand craft” this case also.  But the strategy will not generalize. The basic issue is that your compiler does not know the input expression before-hand.  Technically speaking, the issue is that the “expression is not available at <b>compile time</b>, but only known at <b>run time</b>”. Your code generation module must be more <i>“intelligent”</i> to handle <i>arbitrary expressions</i>.  
                        </p>
                        <p>
                            The root of the problem in the code above is that R0 and R1 has been picked by you and not your compiler.Thus, we must have a <b>register allocation policy</b> (basically a function) that returns a free register whenever we require one. That is, you must design the following functions:
                        </p>
                        <div class="syntax">
                            int getReg()   //  Allocate a free registers
                        </div>
                        
                        <p>
                            That returns the register number of an unallocated register, so that your code for adding 3 and 2 would look like:
                        </p>

                        <div class="syntax">
                            int p = getReg();<br>
                            int q = getReg();<br>    
                            fprintf( target file, “MOV R%d, 3”, p);<br>
                            fprintf(target_ file, “MOV R%d, 2”, q);<br>
                            fprintf(target_file, “ADD R%d, R%d,”, p,q);<br>
                        </div>

                        <p>
                            In addition to allocating registers, you must also have mechanism to <b>release a register</b> back into the register pool. In the above example, after the ADD instruction is generated R1 can be released and send back to the register pool.    
                        </p>

                        <p>
                            For this purpose, you will write a function
                        </p>
                        
                        <div class="syntax">
                            freeReg() //  Releases a register.  
                        </div>
                        
                        <p>
                            To make the allocation  strategy simple,  we suggest that you  generate target code in such a way that  <i>the result of a CPU instruction involving two registers</i> will be always stored in the register with lower index. The above code, for example, stores result of the above computation is kept in R0 and not R1 so that the register with the higher index value can be released. As a consequence, the freeReg() function does not require any arguments.  Instead, freeReg() and getReg() can be designed to keep track of the highest numbered register allocated so far and hence can keep track of the correct register that must be allocated or freed.   
                        </p>
                        <p>
                            The following summarizes the register allocation strategy:
                        </p>
                        <div class="syntax">
                            1. Whenever a register is needed, allocate the lowest numbered register that is free. (Thus, give R0 if possible, otherwise R1 etc.)<br>

                            2.  Whenever we free a register, always release the highest used register that was allocated previously. (Thus, if R0, R1 and R2 were allocated, freeReg() must release R2).
                        </div>
                        
                        <p>
                            Finally, we must design a code generation module.  The strategy here is to start with an expression tree and do the following:
                        </p>

                        <div class="syntax">
                            1.  At the leaf nodes of the tree (corresponding to a NUM),  Allocate a new register and store the number to the register.<br>
                            2.  At the intermediete nodes :<br>
                            &emsp;a.  Generate code for the left subtree (recursively). Find out the register holding the result.<br>
                            &emsp;b.  Evaluate the right subtree (recursively). Find out the register holding the result.<br>
                            &emsp;c.  ADD the contents of the two registers and store the result in the lower numbered register.<br>
                            &emsp;d.  Release the higher numbered register and return.<br>
                        </div>

                        <p>
                            In the above box, as step 2.a and 2.b requires finding the index of the register which stores the result of expression evaluation. The simplest strategy is to design a codeGen() function that can take as input an expression tree and generates code for the expression, <i>returning the index of the register storing the result</i> :  
                        </p>
                        <div class="syntax">
                            #define reg_index int;<br>  
                            reg_index codeGen( struct node *t) {<br>
                            &emsp;..<br>
                            &emsp;..<br>
                            &emsp;return [result-regIndex]<br>   
                            }
                        </div>
                        <p>
                            The codeGen() function takes as input a pointer to the root of an expression tree and generates code for the subtree rooted at that node. After generating code, the function must return the index of the register storing the result. See this <a href="codegen.html" target="_blank">link</a> for furthur details.
                        </p>
                        <p>
                            <b>Task 2</b>: Complete the simple compiler for expression evaluation and generate the executable file. The result of expression evaluation may be stored in the first location of the stack region – memory address 4096.  Note that the XEXE executable format must be adhered so that the XSM simulator can load and execute the file.   
                        </p>
                        <p>
                            <b>Note</b>:  To run the simulator, you must prepare the library.lib together with the XEXE executable file.  Please follow instructions in the <a href="xsm-environment-tut.html" target="_blank">XSM environment tutorial</a>.
                        </p>
                        <p>
                            <b>Exercise 2</b>:  Modify the grammar to 
                            <div class="syntax">E :  E + E | E*E | E-E| E/E | (E) | NUM</div>  Assume standard rules of precedence and associativity. 
                        </p>
                        <p>
                            <b>Exercise 3</b>:  Redo Exercise 2 assuming that the input expression is given in prefix from.
                        </p>
                        <p>
                            <b>Note:</b> Here we assumed that machine registers never get exhausted. XSM provides 20 general purpose registers and these registers are sufficient for all practial purposes.  However, if all registers are exhausted, then space will have to be allocated in memory.  We will not address this contingency in this roadmap. If register pool is exhausted, your compiler may stop compilation and flag "Out of registers"  error.  
                        </p>
                        <hr>
                    </article>
                    <article class="grid col-full" id="nav-stage2">
                        <h2>Stage 2. Introduction to static storage allocation</h2>
                        <p>
                            <b>Prerequisites</b> :
                            <ul>
                                <li id="otis">1.  You must be comfortable with LEX and YACC.  (If you are not, you must first do <a href="lex.html" target="_blank"> LEX tutorial</a>, <a href="yacc.html" target="_blank">YACC Tutorial</a> and <a href="ywl.html" target="_blank"> YACC+LEX tutorial</a>.)</li>
                                <li id="otis">2.  You must have completed the <a href="xsm-environment-tut.html" target="_blank">XSM environment tutorial</a> before starting this stage.</li>
                            </ul>  
                        </p>
                        <p>
                            <b>Learning Objectives</b> :
                            <ul>
                                <li id="otis">In this stage, you will extend the expression evaluator of the previous stage to support a set of pre-defined variables with Input/Output and assignment statements. You will get introduced to the notion of <b>static storage allocation</b> enroute. You will also learn to differentiate between statements and expressions and also construct an <i>abstract syntax tree representation</i> for a program.</li>
                            </ul>
                         </p>
                         <p>
                            Consider a simple programming language with the following syntax:
                            <div class="syntax">
                                Program ::= BEGIN Slist END<br>
                                <br>
                                Slist ::=  Slist Stmt<br>
                                <br>
                                Stmt ::= InputStmt |  OuptputStmt | AsgStmt<br>
                                <br>
                                InputStmt ::= READ(ID);<br>
                                <br>
                                OutputStmt ::== WRITE(E);<br>
                                <br>
                                AsgStmt ::==  ID = E;<br>
                            </div> 
                            Apart from the <a href="lex.html" target="_blank">literal tokens</a>, BEGIN, END, READ, and WRITE are tokens corresponding to keywords “begin”, “end”, “read” and “write”.  ID is a token for variables.  We will permit only variables [a-z].
                         </p>
                         <p>
                            To support variables to appear in expressions, you must add the rule <b>E := ID</b> to the expression syntax used in Stage 1. The above syntax defines a small programming language that permits just straight line programs (programs without conditionals, loops, jumps or such control transfer constructs). There are only 26 pre-defined variables that are supported – a, b,c,..,z. A typical program would look like:
                            <div class="syntax">
                                begin<br>
                                &emsp;read (a);<br>  
                                &emsp;read (b);<br>
                                &emsp;d = a + 2 * b;<br>
                                &emsp;write (a+d);<br>
                                end;   
                            </div>
                         </p>
                         <p>
                            We will assume that variables can store only integers. Handling variables of multiple types will be taken up in subsequent stages.<br><br>  

                            A conceptual point to note here is that apart from the addition of variables, the extended language now has two kinds of constructs – expressions and <b>statements</b>. While an expression evaluates to a value (in this case, we limit ourselves to integer expressions), a statement commands the execution of some action by the machine. For example, the statement <i>read(a);</i> instructs the action of reading a variable from the console into a variable a. <i>write(a+d);</i> instructs evaluation of the expression (a+d) and printing the result into the console output.
                        </p>
                        <p>
                            Another important conceptual point to note is that the introduction of variables also demand binding them to storage (memory) locations. The storage location associated with a variable must hold the value of the variable at each point of program execution. A statement (like the assignment statement or a read statement) that alters the value of a variable must result in a change the value stored in the corresponding storage location.
                        </p>
                        <p>
                            In the present case, the compiler can fix the address for each variable in memory right at the time of program compilation. Since the ABI stipulate that storage allocation must be done in the stack region, we can pre-allocate the first 26 memory locations in the stack region of <a href="abi.html#nav-virtual-address-space-model" target="_blank">memory</a> for the variables a-z. Thus, variable a will refer to contents of address 4096, b to contents of address 4097 and so on. Any time the compiler encounters the variable – say a, the address to be looked at is fixed – in this case 4096. Such allocation policy is called <b>static allocation</b>. In later stages you will encounter situations where it will not be possible for the compiler to fix memory address of a variable at compile time. This leads to <b>run time</b> and <b>dynamic memory allocation</b> policies. For now, we will be content with static allocation.
                        </p>
                        <p> 
                            To implement the above, your compiler must:
                            <ul>
                                <li id="otis">1. Fix the storage location for each variable. As noted above, the first 26 locations of the stack region starting at address 4096 may be assigned for a to z. Note that the XSM machine can store an integer in a single memory location. Hence, for each variable we need to allocate only 1 memory word. Note that "allocation" here means that while generating code, the compiler assumes when it generates code that the variable a is stored in location 4096, b in location 4097 and so forth.</li>

                                <li id="otis"><b>Note</b> : Some programming languages stipulate that variables must be initialized to zero.  In that case, the compiler must generate code to MOV 0 to each of these locations before generating code for statements in the program. Some machines provide machine instructions that support initializing memory to zero.  Certain operating systems would have initialized all memory regions (except those to which code is loaded into) to zero at load time.  We will not pursue these issues here.</li>

                                <li id="otis">2. To translate an assignment statement, the compiler must generate code to evaluate the expression and then MOV the contents of the register storing the result to the memory location allocated for the variable.</li>

                                <li id="otis">3. To translate a Read statement, the compiler must generate code to invoke the <a href="abi.htmll#nav-lowlevel-syscall-interface" target="_blank">read system call</a> passing the address of the variable as argument. Write is implemented similarly.</li>
                            </ul>
                        </p>
                        <p>
                            But before getting into code generation, we must create an <b>abstract syntax tree (AST)</b> for the program.  An abstract syntax tree is a tree representation of the program, just like an expression tree for expressions. An abstract syntax tree for the above program would look like the following:
                        </p>
                        <p>
                            <img src="img/ast_stage2.png">
                        </p>
                        <p>
                            Observe that each node now needs to store distinguishing information like:
                            <ul>
                                <li id="otis">1. Whether it corresponds is a variable, constant, operator, assignment statement, write statement or read statement.</li>
                                <li id="otis">2. In case of operators, the information on the operator must be present.</li>
                                <li id="otis">3. There are also connector nodes which simply connects two statements together.</li>
                            </ul>
                        </p>
                        <p>
                            This leads to the definition of the following node structure:  
                            <script src="js/dd1979bba5d35250a0c9419520a6b5b8.js"></script>
                        </p>
                        <p>
                            <b>Task 1</b> : Use Yacc and Lex to generate abstract syntax tree representation of a program. A file containing the source program will be input to your program.
                        </p>
                        <p>
                            Thus, after parsing, we use the syntax directed translation scheme of YACC to construct an intermediate representation – namely, the abstract syntax tree. This phase of compilation is sometimes called the <b>front end</b> of the compiler. The next step is to recursively traverse the expression tree to generate executable code.  This is typically called the <b>back end</b>. The output of the front end is generally a <b>machine independent intermediate representation</b> like the AST. The back end of course will be dependent on the target platform.  
                        </p>
                        <p>
                            <b>Task 2</b> : Modify CodeGen() function of Stage 1 to generate code for the abstract syntax tree generated as Task 1 above.
                        </p>
                        <p>
                            In the next stage, we will see how program control instructions like if-then-else can be incorporated into the language.
                        </p>
                        <p>
                            <b>Note</b> : An abstract syntax tree is an <a href="https://en.wikipedia.org/wiki/Intermediate_representation" target="_blank">intermediate representation</a> of the source program in a tree from suitable for code generation. There are several other forms of intermediate representations like the three address code form, the static single assignment form etc. This roadmap will be based on the abstract syntax tree representation.   
                        </p>
                        <p>
                            In commercial strength compilers, the source is first translated to intermediate forms like the three address form which is a bit more of a <b>low level representation</b> than the AST. Typically machine independent <a href="https://en.wikipedia.org/wiki/Optimizing_compiler" target="_blank">code optimizations</a> are performed on the intermediate code and only then the back-end code generation is run. This step is followed by another set of machine dependent code optimizations before the target file is finally generated. As these issues are beyond the scope of our project, we will not dwell into these matters further in this roadmap.
                        </p>
                        <p>
                            <b>Exercise 1</b> : Build an <b>evaluator</b> for the program. (Hint: Your front end does not change. But, instead of generating code from the AST, you can recursively "evaluate" it. For storage allocation of variables, you can simply declare an array that can store 26 integers and allocate one entry for each variable).
                        </p>
                        <p>  
                            <b>Note</b> : The compiler generates target code which must be executed by the target machine. In our case, the compiler you wrote as Task 2 actually is a <b>cross compiler</b>. This means that your compiler generated target code that is not for your host system, but on some other target platform – which in our case the simulated XSM machine. The evaluator done in Exercise 1 actually does not generate "code" for any machine. Instead, it executes the program in "then and there". Such a program could be classified as an <b>interpreter</b>. (Unfortunately, the standard terminology in literature associated with the term "interpreter" seems to be contradictory to this classification).
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage3">
                        <h2>Stage 3:  Adding Flow Control Statements</h2>  
                        <p>
                            <b>Prerequisite</b>:  You must read the  <a href="label-translation.html" target="_blank">label translation tutorial</a> before proceeding with this stage.    
                        </p>
                        <p>
                            <b>Learning Objectives</b>:
                            <ul>
                                 <li id="otis">In this stage, you will extend the straight line program compiler of Stage 2 to support control flow constructs like if-then-else, while-do, break and continue. You will encounter integer and boolean expressions and the notion <i>type</i> enroute. You will also learn the use of <i>labels</i> for handling control flow constructs.</li>
                            </ul>
                        </p>
                        <p>
                            The if-then-else and the while-do constructs can be added to the source language of Stage 2 by adding the grammar rule:
                            <div class="syntax">
                                Ifstmt ::=  IF (E) then Slist Else Slist ENDIF<br>
                                &emsp;&emsp;&emsp;&emsp;&emsp;| IF (E) then Slist ENDIF;  
                                <br>
                                Whilestmt ::= WHILE (E) DO Slist ENDWHILE;<br>
                            </div>
                            To permit logical expressions, we need to add to the grammar the following productions:
                            <div class="syntax">
                                E ::= E<E  |  E>E  |  E<=E  |  E>=E  |  E!=E  |  E == E;<br>
                            </div>    
                            A simple program in this language to find the largerst among three numbers would look like the following:
                            <div class="syntax">
                                begin<br>
                                &emsp;read(a);<br>
                                &emsp;read(b);<br>
                                &emsp;read(c);<br>
                                &emsp;if (a &lt; b) then<br> 
                                &emsp;&emsp;if (b &lt; c) then Write(c);  else Write(b); endif; <br> 
                                &emsp;else<br>
                                &emsp;&emsp;if (a &lt; c) then Write(c); else Write(a); endif; <br>
                                &emsp;endif; <br>
                                end <br>
                            </div>
                            Note that we continue to assume that variables hold only integer values. The first task in translation is to complete the front end.
                        </p>
                        <p>
                            There is one important conceptual point to understand here before proceeding to the front end implementation.  With the introduction of logical expressions, there are two <b>types</b> of expressions in the language – <b>arithmetic expressions</b> and <b>logical expressions</b>. An arithmetic expression evaluates to an integer value whereas a logical expression evaluates to a <b>boolean value</b> – that is true/false.
                        </p>
                        <p>
                            The guard of an if-else statement or a while-do statement must be a boolean expression.  On the other hand, the expression on the right side of an assignment statement must be of integer type as variables are assumed to hold integer values only. In other words, the statements given below are <b>invalid</b>. 
                            <div class="syntax">
                                if (a+b) then Write(c);<br>  
                                &emsp;&emsp;OR<br>
                                a = b &lt; c;<br>
                            </div>
                        </p>
                        <p>
                            Your compiler must flag a "<i>type mismatch</i>" error if such constructs are encountered during the AST construction process. A program with type errors must not pass the compiler's type check scrutiny and the compiler must report error without generating code if the program has type errors. Type analysis is a part of the responsibilities of a compiler (normally classified under <a href="https://en.wikipedia.org/wiki/Semantic_analysis_(compilers)" target="_blank">semantic analysis</a>).
                        </p>
                        <p>
                            A simple way to handle this issue is to <i>annotate each node in the AST with a <b>type attribute</b></i> that indicates what is the type of the expression (or subexpression) with this node as the root.
                        </p>
                        <p>
                            For example, consider the AST for the following erratic expression.
                            <div class="syntax">
                                d = ( a + b ) + ( c &lt; 3 )
                            </div>  
                            <p>
                                //FIGURE NEED TO BE ADDED
                            </p>
                        </p>
                        <p>
                            Here, the root of AST is an assignment node which is <b>typeless</b>. (statements have no type, only expressions have a type associated with them). The left subtree of the root is a variable, and hence has type integer. The right subtree is a  <b>+</b>  node of type integer. Hence, at the root, there is no type mismatch. However, the right child of the right subtree has type boolean and does not match the operand type for the + operator. Hence the compiler must terminate compilation flagging error "type mismatch". Note that the compiler can stop processing when the first error is encountered without proceeding further with the tree construction.
                        </p>
                        <p>
                            To implement type checking, add a nodetype field in the AST node structure.  
                            <script src="js/09129e56138b0207d595eaefbf2873cd.js"></script>
<!--                             <div class="syntax">
                                #define inttype 1
                                #define booltype 0  

                                struct node { 

                                 ---
                                  int type;
                                 ---
                                }  
                            </div> -->
							Now for leaf nodes of the tree, since you have either constants or variables, the type must be set to integer. Next, while constructing the tree for intermediate nodes, check whether the types of the children are compatible with the operator at the root. For instance, for the addition operation, the check could be as the following:
							<div class="syntax"> 
							E :== E+E {<br>       
							&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if (($1->nodetype != inttype) || ($2->nodetype !== intype)) {<br>
							&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;error("type mismatch"); <br>
							&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;exit();<br>
							&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;} else {<br>
							&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$$->type = inttype); <br>  
							&emsp;&emsp;&emsp;&emsp;}<br>
							</div>
						</p>
						<p>
							If there is no mismatch, you must annotate root node ($$->nodetype) with the proper type (integer in the above case).
						</p>
						<p>
							<li id="otis">
								<b>Note</b>:  The above check is better done inside the TreeCreate() function so that the YACC file is not cluttered with C statements.
							</li>
						</p>  
						<p>
							The essential idea is that the type of each node can by synthesized from the types of the subtrees. At any stage, the compiler may terminate flagging error if a type error is found.  
						</p>
						<p>
							<b>Task 1</b>:  Complete the front-end module (AST construction) for the programming language. You need to 
							<ul>
								<li id="otis">(1) add additional lexical tokens for the new constructs</li>  
								<li id="otis">(2) make appropriate modifications in the tree node structure including provision for storing type attribute</li>
								<li id="otis">(3) modify the TreeCreate() function ( ) to have three subtrees passed (for if-then-else) etc.</li>
							</ul>
						</p>
						<p>
							<b>Exercise 1</b>:  To test the implementation of Task 1, implement an <b>evaluator</b> for the expression tree.  Test with simple programs like those for finding the largest of 3 numbers, sum of n numbers (n read from input) etc.  
						</p>
						<p>
							The next task is to complete the back-end code generation phase.  For better clarity, we will split the task into two steps.  
						</p>
						<p>
							<ul>
								<li id="otis"><b>Step 1</b>:  Generate code with <b>labels</b>.  At this stage labels will be placed at various control flow points of the target assembly code so that a JMP instruction will only indicate the label corresponding to the instruction to which transfer of program flow must happen.</li>
								<li id="otis"><b>Step 2</b>:  Replace the labels with addresses.</li>
							</ul>
						</p>
						<p>
							<b>Important note</b>: You must have read the <a href="label-translation.html" target="_blank">label translation tutorial</a> before proceeding any further.
						</p>
						<p>
							We will now look at Subtask 1. Consider the following statement:
							<div class="syntax">
								while (a < b) {<br>
								&emsp;&emsp;a = a+1 ;<br>
								}<br>
							</div>
						</p>
						<p>
							The expression tree for the above statement would look like:

							// Give picture here //
						</p>
						<p>
							Suppose variable a is bound to address 4096, b to address 4097, then our plan is to generate code that would look like the following:
							<div class="syntax">
							L1:  <br>
							MOV R0, [4096]&nbsp;&nbsp;// transfer a to R0<br>
							MOV R1, [4097]&nbsp;&nbsp;//  transfer b to R1<br>
							CMP R0, R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//  a&lt;b<br>
							JNZ L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//  if (a&lt;b) is false goto L2  <br>
							MOV R0, [4096]&nbsp;&nbsp;//  transfer a to R0<br>
							ADD R0, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//  add 1  <br>
							MOV [4096], R0&nbsp;&nbsp;// transfer sum back to a<br>
							JMP L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// goto next iteration. <br>
							L2: <br>
							... Next Instruction ..  <br>
							</div>
						</p>
						<p>
							Note the use of labels L1 and L2 indicating control flow points in the above code. A while statement involves two jumps and two labels. The labels are just symbols that are placed at the start of instructions to which jump instructions must branch to. Placing labels in the code relieves us from bothering about the exact memory address to which jump must be made. Of course, this is only a temporary measure. The final target code must not contain labels.
						</p>
						<p>
							Our strategy here is to first generate code with labels and then replace the labels with addresses. To implement the plan, we may name labels in the program L0, L1,.... We must design an <i>int GetLabel()</i> function that returns the index of the next unused label.  Thus the first call to <i>GetLabel()</i> returns 0, next call returns 1 and so forth.
						</p>
						<p>
							The code generation strategy for the while-do statement is illustrated by the following pseudo-code.  
							<div class="syntax">
								int label_1 = getLabel();<br>
								int label_2 = getLabel();<br>
								fprintf (target_file “L%d”, Label_1)  //  Place the first label here.  <br>
								Generate code for the guard expression.    <br>
								Generate code to compare the result to zero and if so jump to label_2 // loop exit   <br>
								Generate code for the body of the while loop.<br>
								fprintf(target_file, “JMP L%d”, label_1);   // return to the beginning of the loop.  <br>
								fprintf(target_file, “L%d”, label_2);    // Place the second label here<br>
							</div>
						</p>
						<p>
							<b>Task 2</b>:  Complete the code generation with labels for while-do, if-then and if-then-else constructs.
						</p>
						<p>
							Now, we must complete Step 2 of replacing the labels with the correct addresses. This is explained in the <a href="label-translation.html" target="_blank">label translation documentation</a>.  
						</p>
						<p>
							<b>Task 3</b>: Read the link specified above and complete the label translation for  if-then, if-then-else and the while-do statement.
						</p>
						<p>
							<b>Exercise 2</b>: Write (a) program to find the largest for a, b, c (values read from input) (b) program to read numbers till 0 is input and output the sum and test your Task 3 code.  
						</p>
						<p>
							<b>Task 4</b>: Add <b>break</b> and <b>continue</b> statements.  Code for these statements need be generated only if they appear inside some while loop.  Otherwise, the compiler may simply ignore these statements, generating no code.  (The primary task is to keep track of which label to jump to when one of these statements is encountered).  
						</p>
						<p>
							<b>Exercise</b> : Add repeat-until and do-while statements to the language with standard semantics.
                        </p>
                        <hr>
                    </article>
                </div>
            </section>
            </body>
        </div>
        <footer class="center part clearfix">
            <ul class="social column3 fleft">
                <li><a href="https://github.com/silcnitc">Github</a></li>
            </ul>
          <div class="up column3 mright"> <a href="#navtop" class="ir">Go up</a> </div>
          <nav class="column3">
            <ul>
              <li><a href="index.html">Home</a></li>
              <li><a href="about.html">About</a></li>
              <!-- <li><a href="uc.html">Contact</a></li> -->
            </ul>
          </nav>
      </footer>
    <!-- Javascript - jQuery
    <script src="http://code.jquery.com/jquery.min.js"></script>-->
    <script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>
    <!--[if (gte IE 6)&(lte IE 8)]>
    <script src="js/selectivizr.js"></script>
    <![endif]-->
    <script src="js/scripts.js"></script>
</html>