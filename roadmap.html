<!Doctype html>
<html lang="en">
    <head>
        <title>Roadmap</title>
        <meta charset="UTF-8">
        <!--<link rel="stylesheet" href="css/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/style_new.css">


    </head>
    <div class="container">
        <header id="navtop">
            <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
            <nav class="fright">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
        			    <li><a href="#">Help</a></li>
        			    <li><a href="#">Code</a></li>
        			    <li><a href="roadmap.html" class="navactive">Roadmap</a></li>
        			    <li><a href="documentation.html">Documentation</a></li>
                </ul>
            </nav>
        </header>
        <div class="Services-page main grid-wrap">
            <header class="grid col-full">
                <hr/>
                <p class="fleft">ROADMAP</p>
                <br>
                <br>
                <!--<a class="button" href="">Download as PDF</a>-->
            </header>
            <aside class="grid col-one-quarter mq2-col-full">
                <menu>
                    <ul>
                        <li class="sec"><a href="#nav-stage0">0. Setup instructions.</a> </li>
                        <li class="sec"><a href="#nav-stage1">1. Understanding lex & yacc.</a></li>
                        <li class="sec"><a href="#nav-stage2">2. Simple Compiler.</a></li>
                        <li class="sec"><a href="#nav-stage3">3. Code Translation.</a></li>
                        <li class="sec"><a href="#nav-stage4">4. Using Typetable.</a></li>
                        <li class="sec"><a href="#nav-stage5">5. Function calls.</a></li>
                        <li class="sec"><a href="#nav-stage6">6. Code Generation for functions.</a></li>
                        <li class="sec"><a href="#nav-stage7">7. User defined Types</a></li>
                        <li class="sec"><a href="#nav-stage8">8. Code Generation for S7.</a></li>
                        <li class="sec"><a href="#nav-stage9">9. Buddy System Allocator.</a></li>
                    </ul>
                </menu>
            </aside>
            <section class="grid col-three-quarters mq2-col-full">
                <div class="grid-wrap">
                    <article class="grid col-full">
                        <h2>Using roadmap</h2>
                        <p>
                        	This roadmap is divided into stages. Each stage is to be done in the sequential order. Incrementally you will build ExpL Compiler according to its specification. Links are provided throughout the document for further reference. There are two kinds of links, <a href="#" class="imp">important links</a> and <a href="#">informative links</a>. You must visit the <a href="#" class="imp">Important links</a>  the read the immediate section to which the link points to,  in order to proceed with the roadmap. <a href="#">Informative links</a> may be clicked if you want more information at a particular point. However this information may not be necessary at that point. You can proceed with the roadmap without visiting these links also.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage0">
                        <h2>Stage 0 : Setup instructions</h2>
                        <p>
                            Through this course we will build a compiler for <a href="expl.html">Experimental Language</a>. Lex and Yacc are lexical and parser tools that make the job of building the compiler easy. Follow the instrcutions to install Lex and Yacc.
                        </p>
                        <h6>Install LEX</h6>
                        <p>
                            Flex is fast lexical analyser. It is used to generate programs which recognize lexical patterns in text. Flex reads the input file for descriptions of these patterns. Pairs of regular expression and C code(rules) forms the description.
                        </p>
                        <p>
                            For Ubuntu Users :
                        </p>
                        <pre>
                            sudo apt-get update
                            sudo apt-get flex
                        </pre>
                        <p>
                            For Fedora Users :
                        </p>
                        <pre>
                            yum install flex
                        </pre>
                        <h6>Install Yacc</h6>
                        <p>
                            Bison is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a C program to parse that grammar. Bison is upward compatible with Yacc: all properly-written Yacc grammars ought to work with Bison with no change.
                        </p>
                        <p>
                            For Ubuntu Users:
                        </p>
                        <pre>
                            sudo apt-get update
                            sudo apt-get insall bison
                        </pre>
                        <p>
                            For Fedora Users
                        </p>
                        <pre>
                            yum install bison
                        </pre>
                        <h6>Install XSM</h6>
                        <p>
                            XSM or Extensible String Machine is a hypotheical machine which the interface as given <a href="abi.html">here.</a> The code generated by the compiler will be in accordance with this interface.
                            <b>Steps :</b>
                        </p>
                        <p>
                            Kuddos !
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage1">
                        <h2>Stage 1 : Understanding Lex & Yacc</h2>
                        <p>
                            To build the compiler with lex and yacc, you need to understand the working of these tools. In this stage, you will write some simple programs in lex and yacc and understanding what actually happens behind the curtain.
                        </p>
                        <h6>Understanding Lex</h6>
                        <ol>
                            <li>Read the sections Introduction, Structures of lex program and yyvariables <a href="lex.html" class="imp">here.</a></li>
                            <li>Create a file number.l with the content as <a href="lex.html#navyytext">yytext_example.l</a></li>
                            <li>Make necessary changes to read input from a file.</li>
                            <li>
                                Make a sample input file,<i>input</i> with the following contents.
                                <pre>
                                    13
                                    45
                                    67&54
                                    99-12-14
                                </pre>
                            </li>
                            <li>
                                Compiler the program using lex with the following command.
                                <pre>
                                    lex number.l
                                </pre>
                                <p>
                                    You obtain a lex.yy.c file, a C program file. Compile it using GCC as follows
                                </p>
                                <pre>
                                    gcc lex.yy.c
                                </pre>
                                <p>
                                    You will now obtain a.out executable file. Execute it with the sample input file.
                                </p>
                                <pre>
                                    ./a.out input
                                </pre>
                                <p>
                                    After following the aboev steps correctly, you will have the following output.
                                </p>
                                <pre>
                                    Found : 13

                                    Found : 45

                                    Found : 67
                                    &Found : 54

                                    Found : 99
                                    -Found : 12
                                    -Found : 14
                                </pre>
                                <p>
                                    You can see that we get the text characters & - and newline and space characters printed as such. This is because we haven't added any rule to ignore those characters. As a compiler writer, we should flag an error when we see a character that is not a part of language and expected.
                                </p>
                                <p>
                                    Firstly, add the following function at in lex file.
                                </p>
                                <pre>
                                    yyerror(char const *s)
                                    {
                                        &nbsp;&nbsp;printf("yyerror %s",s);
                                    }
                                </pre>
                                <p>
                                     So add the rule which flags an error whenever an unexpected charater appears in the language we are parsing. Dont forget to add the rule to ignore whitespaces and new line characters. Note : this rule is added at the end in rules section.
                                </p>
                                <pre>
                                    [ \n\t] {}
                                    .  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ yyerror("Invalid charater "); printf("%s\n",yytext); exit(1); }
                                </pre>
                                <p>
                                    Now again compile the program with lex and gcc commands as given above and execute. You will see the following output.
                                </p>
                                <pre>
                                    Found : 13
                                    Found : 45
                                    Found : 67
                                    yyerror : Invalid charater &
                                </pre>
                            </li>
                            <li>Complete the remaining sections and understand the working of <a href="lex.html#navfunctions">lex</a> tool properly. Do the <a href="lex.html#navexercise">exercises</a> at the end of the lex document.</li>
                        </ol>
                        <h6>Assignment</h6>
                        <p>
                            Find the regular expressions for strings. Write a lex program to read strings and print them.
                        </p>
                        <h6>Understanding Yacc</h6>
                        <p>
                            Through this section, we will write an infix to postfix yacc program by understanding the basics while building it.
                        </p>
                        <ol>
                            <li>Go through the sections <a href="yacc.html#navintro">Introduction</a> and <a href="yacc.html#navstructure">Structure of Yacc Programs</a> in the yacc <a href="yacc.html">document.</a></li>
                            <li>Create a infix_to_postfix.y file with content as in <a href="yacc.html#navexy0d">intopost.y</a></li>
                            <li>Add necessary statements in the program to support operations '/' and '-' .</li>
                            <li>Run the commands below the program to check the correctness of the program.</li>
                            <li>Understand the shift reduce parsing <a href="yacc.html#navshiftreduce">here</a>.</li>
                            <li>Understand the working of the infix_to_postfix program from the section <a href="yacc.html#navinfixtopostfix">here.</a> The use of %left %right can be understood by reading <a href="yacc.html#navconflict">this.</a></li>
                            <li>
                                <p>
                                    When there are lots of grammar rules written in the program, it becomes difficult to figure out the rules which cause the conflict.
                                </p>
                                <p>
                                    To solve such issues, compile your yacc program with the following command
                                </p>
                                <pre>
                                    yacc -v infix_to_postfix.y
                                </pre>
                                <p>
                                    A y.output file will be obtained. Examine the starting lines of lines which gives the state that causes the conflict. Go the state that causes the conflicts and identify the grmmmar rules that lead to these conflicts.
                                </p>
                                <p>
                                    To understand how to work with conflicts, in your program remove the %left and other associativity lines and compile it using the above command and examine your y.output file.
                                </p>
                            </li>
                            <li>Go through the section <a href="yacc.html#navpassingvalues">here.</a> Make necessary changes in your program also to print the values.</li>
                            <li>Complete the <a href="yacc.html#navusingthelexicalanalyzer">exercises</a>.</li>
                        </ol>
                        <h6>Assignment</h6>
                        <ol>
                            <li>Modify the infix_to_postfix.y such that it gives the value of the complete expression as output. (Hint : use $$ to assign value to head of a rule).</li>
                            <li>Now write a program to concatenate two strings using the operator '+'.</li>
                        </ol>
                        <h6>Understanding lex with yacc.</h6>
                        <p>
                            Go through the complete documentation <a href="ywl.html">here.</a> Make sure you practice the following programs given in the documentation while going through the tutorial.
                            <li>Infix to postfix conversion.</li>
                            <li>Read and write pairs.</li>
                            <li><b>Simple Calculator.</b></li>
                        </p>
                        <p>
                            You will also see how to build an expression tree and evaluate an expression. It is very necessary to understand these basic concepts of expression tree before going further. Build a calculator using expression trees yourself after going through the tutorial.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage2">
                        <h2>Stage 2 : Simple Compiler</h2>
                        <p>
                            From here on, we will build the compiler in stages. In this stage, we will build a simple single line interpreter. We will all single letter varaiables a | b | .... | z of integer type. We will have read and write functions, assignment operator, addition and multiplication operations, allowing paranthesis in the expression.
                        </p>
                        <p>
                            Follow the steps below.
                            <ol>
                                <li> Create an expl.l file for lexical analysis and expl.y for parsing.</li>
                                <li>
                                    <p>
                                        In expl.y, set the stack type with a union of character and integer.
                                    </p>
                                    <pre>
                                        %union{
                                            &nbsp;&nbsp;int integer;
                                            &nbsp;&nbsp;char character;
                                        };
                                    </pre>

                                </li>
                                <li>
                                    <p>
                                        We have numbers, single letter variable, + , * , = , read , write for which we will have tokens NUM, ID , PLUS , MUL , ASGN , READ , WRITE repectively . For '(' , ')' , ';' we will pass them as yytext itself.
                                    </p>
                                    <p>
                                        So we have the following rules in expl.l (Note : Add the necessary declarations in the declarations section, and yywrap() in auxiliary functions section).
                                        <pre>
                                            [a-z] &nbsp;&nbsp;&nbsp;{ yylval.character = yytext[0]; return ID;}
                                            [0-9]+ &nbsp;&nbsp;{ yylvavl.integer = atoi(yytext); return NUM;}
                                            "read"  &nbsp;&nbsp;{ return READ;}
                                            [=]    &nbsp;&nbsp;&nbsp;&nbsp; { return ASGN;}
                                        </pre>
                                    </p>
                                    <p>
                                        Add the rules for write, plus, minus , parathensis and semicolon. Make sure you write rules to ignore the whitespaces.
                                    </p>
                                </li>
                                <li>
                                    Next step is to add the grammar rules in yacc. Whenever a grammar rule is added, make sure you add the tokens and type of non-terminals in the rule in auxiliary declaration section.
                                </li>
                                <li>Add the rule for expr as in the expression program in previous stage.</li>
                                <li>
                                    Every ID has a value an therefore it is an expression.Add the following grammar rule also :
                                    <pre>
                                        expr : ID
                                    </pre>
                                </li>
                                <li>
                                    <p>
                                        As we have only singled letter variables of integer type, we will have only 26 variables.So to store the values of the variables that we obtain at the run time of the program, we will use
                                    </p>
                                    <pre>
                                        int *var[26];
                                    </pre>
                                    <p>
                                        if variable is unassigned, print an error, else assign the value of the variable ID $1 to the head of rule expr $$. So you will have the actions as follows:
                                    </p>
                                    <pre>
                                        expr : ID {
                                                    if( var[$1 - 'a'] == NULL)
                                                        printf("unassinged varaiable");
                                                    else
                                                        $$ = *var[$1 - 'a'];
                                                  }
                                    </pre>
                                    <p>
                                        Don't forget to add type integer for the non-terminal expr.
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        Assignment, read and write are statements of the program.
                                    </p>
                                    <pre>
                                        stmt : ID ASGN expr ';'
                                             | READ '(' ID ')' ';'
                                             | WRITE '(' ID ')' ';'
                                             ;
                                    </pre>
                                </li>
                                <li>Now we will add actions for read statement.
                                    <ul>
                                        <li>If the varaiable was unallocated before, do malloc.</li>
                                        <li>Read value for the variable from standard input</li>
                                    </ul>
                                    <pre>
                                        if(var[$3-'a'] == NULL){
					                    &nbsp;&nbsp; var[$3 - 'a'] = malloc(sizeof(int));
                                        }
                                        scanf("%d",var[$3-'a']);
                                    </pre>
                                    <p>
                                        Add actions for assignment and write statements similarly.
                                    </p>
                                </li>
                                <li>A program has one or more than one statements. Single line program consists of statement block and ends with a new line.So we will have the following rules.
                                    <pre>
                                        Program : slist NEWLINE
                                                ;
                                        slist   : slist stmt
                                                | stmt
                                                ;
                                    </pre>
                                </li>
                                <li>Add the necessary main function in yacc file.</li>
                                <li>Run the commands
                                    <pre>
                                        yacc -y -d expl.y
                                        lex expl.l
                                        gcc y.tab.c lex.yy.c
                                        ./a.out
                                    </pre>
                                </li>
                                <li>Give the following input:
                                    <pre>
                                        read(a); read(h); c=10; write(a); a = a+h*c; write(a);
                                    </pre>
                                </li>
                                <li>Check if your program runs properly.</li>
                            </ol>
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage3">
                        <h2>Stage 3 : Code Translation</h2>
                    </article>
                    <article class="grid col-full" id="nav-stage4">
                        <h2>Stage 4 : Using Typetable</h2>
                        <p>
                            In this stage, we will modify the stage 2 interpreter.
                            <ul>
                                <li>Allow variables of the form given <a href="expl.html#expl-identifiers" class="imp">here.</a></li>
                                <li>Add data types : int and str.</li>
                                <li>Add conditional and iterative statements, logical expressions, break and continue statements as given <a href="expl.html#nav-stmts-and-exprs" class="imp">here.</a></li>
                            </ul>
                            This stage requires the understanding of <a href="Data_Structures.html">data structures</a> : <a href="Data_Structures.html#nav-typetable" class="imp">type table</a>, <a href="Data_Structures.html#nav-global-symbol-table" class="imp">symbol table</a> and <a href="Data_Structures.html#nav-abstract-syntax-tree" class="imp">abstract syntax tree</a>.
                        </p>
                        <p>
                            Follow the below steps to make changes for variables to be user-defined.
                            <ol>
                                <li>Modify the regular expression for ID in your lex file to satify the form given in the <a href="expl.html#expl-identifiers">expl documentation.</a>, i.e, they can be user-defined variables.</li>
                                <li>
                                    <p>
                                        Create a new file symboltable.h, add the structure of <a href="Data_Structures.html#gist28650622" class="imp">Symbol Table.</a>We will use this symbol table to store the information regarding the variable. As of now we don't require the arglist, fbinding fields of the Symbol Table.
                                    <br>
                                        <b>Note</b> : Whenever we add data structures to our program, we add its structures, global declarations and associated function declarations in the .h file and we implement the associated functions in the .c file. This will help you keep the code neat and easy to understand.
                                    </p>
                                </li>
                                <li>In compiler, we store the memory address allocated to the variable, while in the interpreter, we will store the value of variable in the binding field. Therefore, change the type of binding field to union Constant which has the following structure
                                    <pre>
                                        union Constant{
                                            &nbsp;&nbsp;int intval;
                                            &nbsp;&nbsp;str strval;
                                        };
                                    </pre>
                                We use a union here because <a href="expl.html#nav-data-types">expl</a> supports two primitive types int and str. Declare a global variable GSymbolHead which will act as head pointer to the global symbol table.
                                <p>
                                    You may go through the illustration under the <a href="Data_Strcutures.html#nav-global-symbol-table">symbol table section</a> for better understanding.
                                </p>
                                </li>
                                <li>Go though the section <a href="Data_Structures.html#nav-typetable"> Type Table</a>. Take down the structure to symboltable.h file. Go through the illustrations also. Declare a global variable TypeTableHead which will act as head pointer of type table.</li>
                                <li>Now implement the functions TTableCreate(), TLookup(), TInstall() under the associated methods for typetable.</li>
                                <li>Implement functions GInstall(), Glookup(), AddGtype() and GAppend() associated with symbol table.</li>
                            </ol>

                        </p>
                    </article>
                </div>
            </section>
        </div>
    </div>
</html>
