<!Doctype html>
<html lang="en">
    <head>
        <title>Data Structures</title>
        <meta charset="UTF-8">
        <!--<link rel="stylesheet" href="css/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/style_new.css">
        <link rel="stylesheet" href="js/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4.css"><div id="gist28627206" class="gist">
        <link rel="stylesheet" href="js/embed-cbe5b40fa72b0964f90d4919c2da8f8f94d7c9f6c2aa49c07f6fa3.css"><div id="gist28627206" class="gist">


    </head>
    <div class="container">
        <header id="navtop">
            <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
            <nav class="fright">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
        			    <li><a href="#">Help</a></li>
        			    <li><a href="#">Code</a></li>
        			    <li><a href="roadmap.html">Roadmap</a></li>
        			    <li><a href="documentation.html" class="navactive">Documentation</a></li>
                </ul>
            </nav>
        </header>
        <div class="Services-page main grid-wrap">
            <header class="grid col-full">
                <hr/>
                <p class="fleft">Data Structures</p>
                <br>
                <br>
                <a class="button" href="">Download as PDF</a>
            </header>
            <aside class="grid col-one-quarter mq2-col-full">
              <menu>
                <ul>
                  <li><a class="sec" href="#nav-compile-structures">Compile Time Data Structures</a></li>
                  <li><a class="subsec" href="#nav-typetable">Type Table</a></li>
                  <li><a class="subsec" href="#nav-symbol-table">Symbol Table</a></li>
                  <li><a class="subsubsec" href="#nav-global-symbol-table">Global Symbol Table</a></li>
                  <li><a class="subsubsec" href="#nav-local-symbol-table">Local Symbol Table</a></li>
                  <li><a class="subsec" href="#nav-abstract-syntax-tree">Abstract Syntax Tree</a></li>
                  <li><a class="sec" href="#nav-run-structures">Run Time Data Structures</a></li>
                  <li><a class="subsec" href="#nav-stack">Stack</a></li>
                  <li><a class="subsec" href="#nav-heap">Heap</a></li>
              </ul>
              </menu>
            </aside>
            <section class="grid col-three-quarters mq2-col-full">
                <div class="grid-wrap">
                    <article class="grid col-full">
                        <h2>COMPILE TIME DATA  STRUCTURES</h2>
                    </article>
                    <article class="grid col-full" id="nav-typetable">
                        <h2>Type Table</h2>
                        <p>
                            The Type Table stores all the necessary information regarding the various user defined types in the source program. The compiler creates an entry in the Type Table for each user defined type. In addition to this, there are default entries created for primitive types (<i>int</i>, <i>str</i>) and special entries <i>null</i>, <i>boolean</i> and <i>void</i> for the internal purposes of the interpreter. The default and special entries are made beforehand whereas entries for user defined types are made as the Type Declaration Section of the source code is parsed.
                        </p>
                        <h4>Structure</h4>
                        <p>
                            The structure of Type Table is as follows:
                        </p>
                        <script src="js/9d481cdd2e29c3eadc3d.js"></script>
                        <p>
                            The variable 'fields' is a pointer to the head of 'fieldlist'. Here 'fieldlist' stores the information regarding the different fields in the case of a user-defined type.
                        </p>
                        <script src="js/79a0b8b91299662b744d.js"></script>
                        <h4>Associated Methods</h4>
                        <ul>
                            <li>void TypeTableCreate() : Function to initialise the type table entries with primitive types <i>(int,str)</i> and internal data types <i>(boolean,null,void)</i>.</li>
                            <li>struct Typetable* TLookup(char *name) : Search through the type table and  return pointer to type table entry of type 'name'. </li>
                            <li>struct Typetable* TInstall(char *name, struct Fieldlist *fields) : Creates a type table entry for the type of 'name' with given 'fields' and returns the pointer to the type table entry.</li>
                            <li>void FInstall(char *name, struct Typetable *type) : Adds a fieldlist entry with given 'name' and 'type'.</li>
                            <li>struct Fieldlist* FLookup(char *name, struct Fieldlist *list) : Searches for a field of given 'name' in the given 'fieldlist' (of some user-defined type) and returns a pointer to the matching entry.</li>
                        </ul>
                        <h4>Illustration</h4>
                        <p>
                            Let us consider the following sample code:
                        </p>
                        <script src="js/67898e19a3cb8f2dc010.js"></script>
                        <ol>
                            <li>The type table is first created and initialised to contain the default entries for each of the primitive and internal datatypes. This is done through a call to the function TypeTableCreate() from main function before yyparse() is called to start parsing the code. After the execution of TypeTableCreate() , the type table will be as follows:
                                <br/><img src="img/data_structure_1.png" style="width:40%;margin-top:1em;margin-bottom:1em"></img><br>
                            </li>
                            <li>As soon as the compiler encounters the declaration of a user defined type, it is installed into the type table. Subsequently the fields are attached to this type table entry. For instance, in the case of the user-defined type <i>linkedlist</i>, as soon as  the name <i>linkedlist</i> is encountered, a type table entry with 'name' set to <i>linkedlist</i> and 'fields' set to <i>NULL</i> is created. Later, on finishing the complete parse of the type definition, the fieldlist is created and it is attached to the type table entry. <br><b>NOTE</b> : A type table entry is created as soon as the type name is seen. This is because a field of the type may be of same type (For example, just like <i>next</i> is of type <i>linkedlist</i> in the type definition of <i>linkedlist</i>). When the 'fieldlist' is created, the type of the field is set by looking up the type table.
                                <br/><img src="img/data_structure_2.png" style="width:70%;margin-top:1em;margin-bottom:1em"></img><br>
                            </li>
                            <li>Similar actions are carried out for user-defined type <i>marklist</i> also.
                                    <br/><img src="img/data_structure_3.png" style="width:90%;margin-top:1em;margin-bottom:1em"></img><br>
                            </li>
                            <li>Once the type declaration section is completely parsed, the type table is fully created and will not be further modified or updated.</li>
                        </ol>
                    </article>
                    <article class="grid col-full" id="nav-symbol-table">
                        <h2>Symbol Tables</h2>
                        <p>
                            Symbol tables are used to store information pertaining to the variables and functions in a program.
                        </p>
                        <h4 id="nav-global-symbol-table">Global Symbol Table</h4>
                        <p>
                          The global symbol table stores information pertaining to all the global variables and functions in an ExpL program.
                        </p>
                        <h6>Structure</h6>
                        <p>
                            The structure of Global Symbol Table(GST) is as follows:
                        </p>
                        <script src="js/4f483469c1dccd2e9a64.js"></script>
                        <p>
                            <span style="color:red;font-size:12px;">&#10011;</span><b>NOTE</b>: In the case of a compiler, fbinding must store the starting address of the function's code in memory. A call to the function must translate into an assembly level call to the function's code in memory.  Hence, in this case fbining has to be an integer storing a memory address.
                        </p>
                        <p>
                            Arglist is used to store information regarding the types and names of the arguements. ArgStruct has the following structure.
                        </p>
                        <script src="js/f583d3a3ee857a50d496.js"></script>
                        <p>Read about ASTNode <a href="#nav-abstract-syntax-tree">here</a>.</p>
                        <h6>Associated Methods</h6>
                        <ul>
                            <li>struct Gsymbol* GInstall(char *name,struct Typetable *type, int size, struct ArgStruct *arglist) : Creates a  Global Symbol object of given 'name', 'type', 'size' and 'argument list' and assigns a 'binding' to the variable.</li>
                            <li>struct Gsymbol* GLookup(char *name) : Search for a GST entry with the given 'name', if exists, return pointer to GST entry else return NULL.</li>
                        </ul>
                        <h6>Illustration</h6>
                        <p>
                            Continuing with earlier example, let us add Global declaration section to it.
                        </p>
                        <script src="js/f1d20b44ca4389ed1be6.js"></script>
                        <ol>
                            <li>As soon as the compiler encounters the global declaration of a variable or funtion, it is installed into Global Symbol Table. Subsequently, the arguments are attached to the entry in case of functions. Following is how GST looks when <i>studentname</i> is installed.
                                <a href="img/data_structure_5.png">  <img src="img/data_structure_5.png" style="height:90%"></img></a>
                            </li>
                            <li>
                                Similarly for <i>rollno,average,findaverage(linkedlist marks)</i>, symbol table entries are formed and installed. The fbinding for a function is the abstract syntax tree of the function definition and is set only after complete parsing of the function definition.
                                <br><a href="img/data_structure_6.png">  <img src="img/data_structure_6.png"></img></a>
                            </li>
                            <li>After this, the types for rollno,average and findaverage will be set and these objects are appended to the global symbol table. The final Global Symbol table looks as follows:
                                <br><a href="img/data_structure_7.png">  <img src="img/data_structure_7.png"></img></a>
                            </li>
                        </ol>
                        <h4 id="nav-local-symbol-table">Local Symbol Table</h4>
                        <p>
                          In addition to the global symbol table, the ExpL compiler maintains a separate local symbol table for each function for storing information regarding the functions arguments and local variables. Each function has its own list of local variables. So each function has its own LST.
                        </p>
                        <h6>Structure</h6>
                        <script src="js/b2f1dd17ecc21780f898.js"></script>
                        <h6>Associated methods</h6>
                        <ul>
                            <li>struct Lsymbol* LInstall(char *name,struct Typetable *type) : Creates a local symbol tbale with given 'name' and 'type' and also sets its 'binding'.</li>
                            <li>struct Lsymbol* LLookup(char *name) : search the LST and if any entry with given 'name' is found ,return the entry,else returns NULL. </li>
                        </ul>
                        <p>
                            Arrays cannot be local variables, so we don't need to store the size of a variables. Also nested functions are not allowed in ExpL, so we don't require fbinding and arglist as in Gsymbol. The LST is formed for the Local Declaration Section in the same way GST was created for the Global declaration section.
                        </p>
                        <p>
                            Memory is allocated for local variables of a function from a seperate memory area called the <a href="#nav-stack" class="imp">stack</a>. Hence, the binding for a local variable is the relative address of the variable with respect to the base of the <a href="#"><b>Activation Record</b></a>. The <a href="#"><b>Base Pointer</b></a> points to the base of an activation record of a function. The binding is added to the Base Pointer to obtain the address of variable in stack. This will be explained in detail later.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-abstract-syntax-tree">
                        <h2>Abstract Syntax Tree</h2>
                        <p>
                            The machine independent <b>front-end</b> phase of a compiler constructs an intermediate representation of the source program called the <b>Abstract Syntax Tree (AST)</b>. An interpretter will evaluate the AST whereas a compiler will run a machine dependent <b>back-end</b> to generate a target assembly language program. The following structure may be used to represent a node of the AST.
                        </p>
                        <script src="js/ecec5cc25b3834dd40a8.js"></script>
                        <p>
                            The union Constant is used to store the value of an integer or sting constant.
                        </p>
                        <script src="js/8cb0db40153ff46dabfa.js" charset="utf-8"></script>
                        <h6>Associated methods</h6>
                        <ul>
                            <li>struct ASTNode* TreeCreate (</br><span style="padding-left:5em;">struct Typetable *type,</span></br><span style="padding-left:5em;">int nodetype,</span></br><span style="padding-left:5em;">char *name,</span></br><span style="padding-left:5em;">union Constant value,</span></br><span style="padding-left:5em;">struct ASTNode *arglist,</span></br><span style="padding-left:5em;">struct ASTNode *ptr1,</span></br><span style="padding-left:5em;"> struct ASTNode *ptr2,</span></br><span style="padding-left:5em;"> struct ASTNode *ptr3</span></br><span style="padding-left:5em;">) </span></br>Creates a node with the fields set according to the arguements passed.</li>
                            <li>regindex evaluate(struct ASTNode *t)</br> Evaluation of an AST node results in a value.  A compiler generates code for evaluating an AST node and assigns the result of evaluation to a register.  An interpreter directly evaluates the AST node and simulates the compiler by storing the result in an array (called reg) and returning the index. We make use of the following structure to store the results of evaluation by an interpreter:
                            <script src="https://gist.github.com/vishnupriyam/14917a901e497a38abf7.js"></script>
                            <p>
                                In 'valstruct' the field 'valtype' can take one of the following values:
                                <ol>
                                    <li>EMPTY : Indicates that no value is stored in it.</li>
                                    <li>INT : Indicates that value stored in the union constant 'value' is an integer.</li>
                                    <li>STR : Indicates the value stored in the union constant 'value' is a string.</li>
                                    <li>H_INDEX : Indicates that valstruct stores the (integer) index of a location in the heap.</li>
                                </ol>
                            </p>
                            </li>
                        </ul>
                        <h6>Illustration</h6>
                        <p>
                            Consider the following program
                        </p>
                        <script src="https://gist.github.com/vishnupriyam/da8d8ee3b8fe00c48e8b.js"></script>
                        <p>
                            The abstract syntax tree for the above program will look as follows precisely.
                        </p>
                        <img src="img/data_structure_27.png" alt="" />
                        <!--
                        <p>
                            Continuing with the previous example,
                        </p>
                        <script src="js/089ce170e43be95bff60.js"></script>
                        -->

                    </article>
                    <article class="grid col-full" id="nav-run-structures">
                        <h2>RUN TIME DATA STRUCTURES</h2>
                        <p>
                            A compiler must accurately implement the abstractions embodied in the source language definition. Names,scope, bindings, data types, operators, flow-control constructs are some of the abstractions. Compiler creates and manages a run-time environment in which a variety of issues such as allocation of storage locations for the objects named in the source program, the linkages between procedures, the mechanisms for passing parameters.From the perspective of compiler writer, the executing target program has its own logical address space in which each program value has its location. Following is the representation of run-time memory.
                        </p>
                        <img src="img/data_structure_9.png" style="margin-left:40%"></img>
                        <p>
                            Stack and heap are dynamic, their size changes as the program executes. We will discuss these structures in detail.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stack">
                        <h2>Stack</h2>
                        <p>
                            The stack is used to store data structures called activation records that are generated during procedure calls.An activation record is used to store the information such as value of program counter and machine registers when a function call occurs. When control of returns from the function call, the activation of the calling procedure can be restarted after restoring the relevant registers and setting program counter to the point immediately after the call. Also, data of objects whose lifetime are contained in that of an activation can be allocated on the stack along with other information associated with activation.
                        </p>
                        <h6>Structure</h6>
                        <p>
                            So, for the implementation of the interpreter, we create a stack which is an array of memstruct. Memstruct has the following structure.<br>
                            <b>NOTE</b> : for compiler, the stack structure and functions supported functions depends and is taken care of by the target machine.
                        </p>
                        <script src="js/29434fa8b266749088cb.js"></script>
                        <p>
                            The type field in memstruct can take the following values
                        </p>
                        <ol>
                            <li>MEMSTRUCT_EMPTY : Indicates no value is stored in it.</li>
                            <li>MEMSTRUCT_INT : Indicates that it stores an integer value.</li>
                            <li>MEMSTRUCT_STR : Indicates that it stores a string value.</li>
                            <li>MEMSTRUCT_BIND : Indicates that it points to a location in heap,i.e, the intval field in the union constant value stores the index of heap array location it points to.</li>
                            <li>MEMSTRUCT_SIZE : Indicates that this memstruct is the first index of the allocated block for a dynamically allocated variable, and it stores the size of the block allocated for the variable.</li>
                        </ol>
                        <ol>

                        </ol>
                        <h6>Associated methods</h6>
                        <ul>
                            <li>void push(struct valstruct *v) : pushes the values in valstruct to stack accordingly.</li>
                            <li>struct valstruct* pop() : pops a value on top of the stack as a valstruct.</li>
                            <li>void load(struct memstruct *m, struct valstruct *v) : loads the values in stack location pointed by m to the value structure v</li>
                            <li>void store(struct memstruct *m,struct valstruct *v) : stores the values in value structure v to the stack location pointed by m.</li>
                        </ul>
                        <p>
                            NOTE : valstruct and memstruct structures have been used here to keep the fine line between a value object and a object in the memory.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-heap">
                        <h2>Heap</h2>
                        <p>
                            A storage allocation decision can be static or dynamic. A decision is dynamic if it can be decided only while the program executes. In simple terms, consider the previous example, the size of the linkedlist marks is not known at the compile time, its size is only known at the run-time when we read in the count of subjects.
                        </p>
                        <p>
                            In interpreter, for heap we will be using an memstruct array of size 1024.
                        </p>
                        <h6>Associated methods</h6>
                        <ul>
                            <li>void intialise() : To initialise the heap with required initial values.</li>
                            <li>int alloc(int size) : allocates continuos locations of given size and returns the starting address of allocated block.</li>
                            <li>int free(int addr) : frees the memory block starting with the given addr are erasing the data in that block and returns a value indicating the success and failure of free operation.</li>
                        </ul>
                        <h6>Allocation algorithms</h6>
                        <p>
                            The two types of allocation-deallocation algorithms we will discuss here for heap management are fixed memory and buddy memory management.
                        </p>
                        <h6>Fixed Memory Allocation</h6>
                        <p>
                            In this algorithm, the chunk size allocated is fixed. Lets call the fixed size as HB_SIZE, say 8. The heap is considered here as a list of blocks of HB_SIZE.
                        </p>
                        <p>
                            The first block in the list is reserved. Initially, The first index of reserved block stores the index of first free block. The first index of every free block stores the index of next available free block. The last block stores -1 in the first index. This is how it looks initially(after the call to initialise function).
                        </p>
                        <img src="img/data_structure_10.png" alt="Figure : Intial Heap diagram" />
                        <p>
                            Following is the <b>allocation algorithm.</b>
                        </p>
                        <ol>
                            <li>First index of reserved block is checked, let the value be v.</li>
                            <li>If v is -1, return -1 indicating no free blocks are available.</li>
                            <li>Else, allocate the free block at v, after copying the next free block index stored at v to the reserved block.Return v.</li>
                        </ol>
                        <p>
                            Following is the pseudo code of the algorithm.
                        </p>
                        <script src="js/60abadc1a9b7554fba73.js"></script>
                        <p>
                            NOTE : heap is an array of memstructs.
                        </p>
                        <p>
                            Following is the <b>deallocation algorithm.</b>
                        </p>
                        <ol>
                            <li>The arguement passed : starting address of the block(say s) to be deallocated</li>
                            <li>The block s is cleared by setting all memstructs in the block to type MEMSTRUCT_EMPTY.</li>
                            <li>The value in the first index of reserved block is copied to first index of block s.</li>
                            <li>The first index of reserved block is set with starting address of block s.</li>
                        </ol>
                        <h6>Illustration</h6>
                        <p>
                            This section shows how the heap looks after each step of allocation or free. This is for the better understanding of the algorithms.
                        </p>
                        <ul>
                            <li>
                                <p>
                                    x = alloc();
                                </p>
                                <img src="img/data_structure_11.png" alt="" />
                                <p>
                                    x is a memstruct in the run-time stack of type MEMSTRUCT_BIND with intval 8.
                                </p>
                            </li>
                            <li>
                                <p>
                                    y = alloc();
                                </p>
                                <img src="img/data_structure_12.png" alt="" />
                            </li>
                            <li>
                                <p>
                                    z = alloc();
                                </p>
                                <img src="img/data_structure_13.png" alt="" />
                            </li>
                            <li>
                                <p>
                                    dealloc(x);
                                </p>
                                <img src="img/data_structure_14.png" alt="" />
                            </li>
                            <li>
                                <p>
                                    dealloc(z);
                                </p>
                                <img src="img/data_structure_15.png" alt="" />
                            </li>
                            <li>
                                <p>
                                    z = alloc();
                                </p>
                                <img src="img/data_structure_16.png" alt="" />
                            </li>
                        </ul>
                        <h6>Buddy Memory Allocation</h6>
                        <p>
                            In this technique, memory is divided into partitions to try to satisfy a memory request as suitably as possible. This technique makes use of splitting memory into halves to try to give a best-fit.
                        </p>
                        <p>
                            Every memory block in this technique has an order, a number ranging from 0 to a specified upper limit. The size of block of order n is 2<sup>n</sup>. So the blocks are exacly twice the size of blocks of one order lower. Power-of-two block sizes makes address computation simple, because all buddies are aligned on memory address boundaries that are powers of two. When a larger block is split, it is divided into two smaller blocks, and each smaller block becomes a unique <b>buddy</b> to the other. A split block can only be merged with its unique buddy block, which then reforms the larger block they were split from.
                        </p>
                        <p>
                            Starting off, the size of the smallest possible block is determined, i.e. the smallest memory block that can be allocated. The smallest block size is then taken as the size of an order-0 block, so that all higher orders are expressed as power-of-two multiples of this size. In our implementation, we consider the smallest memory block size to be 8. So, the memory block sizes will be 8, 16, 32, 64, and so on. In our implementation, we take the heap of size 1024.
                        </p>
                        <p>
                            In our implementation, we have a heap of size 1024. The smallest block size possible in the heap is 8 (order 0). The highest block size of 2<sup>n</sup> that is free is 1024.We maintain a free list for all possible block sizes. So we have freelists for sizes 8,16,32,64,128,256,512 and 1024, i.e, we maintain eight freelists.
                            <ul>
                                <li>We have only one block of size 1024 and so the size of freelist for 1024 is 1(2<sup>0</sup>).</li>
                                <li>In the 1024 sized heap, we have two blocks of size 512. Note that, both blocks cannot be free at the same time. If both blocks are free, they will be merged to a free block of size 1024(whose information will be maintained in the freelist for blocks of 1024 size). So at a time, maximum number of blocks that are free of size 512 is 1 ( 2<sup>0</sup>).</li>
                                <li>Similarly in case of blocks of size 256, 1024 sized heap has 4 blocks of size 256 (say a,b,c and d in their respective order).a and b are buddies of each other, of which both cannot be free at a time due to merging, so only one of them can be free. Similarly in case of c and d, only one of them can be free. 1 + 1 , 2 ( 2<sup>1</sup>) is the maximum size of free list for blocks of 256.</li>
                                <li>Similarly, there are 8 blocks of 128 in 1024 (a,b,c,d,e,f,g and h). (a,b)(c,d)(e,f)(g,h) are buddy pairs and only one of each pair can be free. So the maximum size of freelist for blocks of 128 is 4 ( 2<sup>2</sup>).</li>
                                <li>Similarly, the maximum size of freelist for blocks of sizes 64,32,16 and 8 are 8 ( 2<sup>3</sup>),16( 2<sup>4</sup>),32( 2<sup>5</sup>) and 64( 2<sup>6</sup>) respectively.</li>
                            </ul>
                            So, the size of the complete freelist is 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + 2<sup>3</sup> + 2<sup>4</sup> + 2<sup>5</sup> +2<sup>6</sup> = 128.
                        </p>
                        <p>
                            We will maintain the freelist inside the heap, So initially we won't have the complete heap of 1024 free. So we need not require a freelist for size 1024. We will store the complete freelist in a 128 sized block. Therefore, initially we have the first 128 block(0-127) of the heap reserved for freelist maintainence. Then we have a 128 sized free block(128-255), then a 256 block(256-511) and then a free block of 512 size(512-1023). Following is the diagrammatic representation of the heap initial status.
                        </p>
                        <img src="img/data_structure_17.png" alt="" />
                        <p>
                            The free-list in the heap has to be initialised as above. Also, the first index of each allocated block through alloc function will store the size of allocated block. This is to figure out the size that has been allocated when the dealloc function is called for a variable, which provides only the starting address of the block that has been allocated.
                        </p>
                        <p>
                            Following is the <b>allocation algorithm</b> : (argument : Request for a block of size 'A')
                        </p>
                        <ul>
                            <li>Look for a memory slot of suitable size(i.e, the <b>minimal 2<sup>k</sup> block</b> that is larger or equal to that of the requested memory A + 1, a plus one as first index is used to store the size of block allocated), lets call the ceiled size as 'B'.
                                <ol style="list-style-type:upper-roman">
                                    <li>If found, the starting index of the allocated block is returned to the program after removing it from the freelist.</li>
                                    <li>If not, it tries to make a suitable memory slot by following the below steps
                                        <ol style="list-style-type:lower-alpha">
                                            <li>Split a the <b>next larger suitable free memory slot</b> into half.(Remove the next larger suitable free memory slot from it free list and add both the halves to the corresponding freelist).(Note : of there is no larger free memory slot - return -1 indicating that no free space is available).</li>
                                            <li>If the required size 'B' is reached, one of the halves is allocated to the program.</li>
                                            <li>Else go to the step a and repeat it until the memory slot of required size 'B' is found.</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                        </ul>
                        <p>
                            Following is the <b>deallocation algorithm</b> (arguement : the starting address of the allocated block)
                        </p>
                        <ol>
                            <li>Get the size, say 's' of the block from the first index of the block. Free the complete block with the help of size obtained by setting all the memstruct type to MEMSTRUCT_EMPTY.</li>
                            <li>Check if the buddy of the block is free by checking the whether the buddy's starting address is present in the free list for blocks of size 's' .</li>
                            <li>If the buddy is not free, add the current freed block to its free list.</li>
                            <li>If the buddy is free, remove the buddy from the freelist and combine the two, and go back to step 2 to check for the buddy of merged block. Repeat this process until the upper limit is reached or buddy is not free.</li>
                        </ol>
                        <p>
                            The psuedo code for alloc and dealloc functions is as follows :
                        </p>

                        <script src="js/459816dfb4d095778c37.js"></script>
                        <h6>Illustration</h6>
                        <p>
                            For a better understanding purpose, we will have a simple illustration of how heap memory looks like through a set of some allocations and deallocations.
                        </p>
                        <p>
                            For illustration, we will have 64-sized heap and smallest block size as 8. So we free lists for sizes 8,16 and 32 of lengths 4 ,2 and 1. So we will use a 8-size block to store the free-list.
                        </p>
                        <ol>
                            <li>
                                <p>
                                    The heap looks initially as follows.
                                </p>
                                <img src="img/data_structure_18.png" alt="" />
                            </li>
                            <li>
                                <p>
                                    Request for memory of size 5. Lets call this request as A. The nearest 2^k value for 5 is 8. We search for a 8 sized free block. We have one such! Allocate it!

                                </p>
                                <img src="img/data_structure_19.png" alt="" />
                                <br/>
                            </li>
                            <li>
                                <p>
                                    Next we will have a reuqest B of size 14.
                                </p>
                                <img src="img/data_structure_20.png" alt="" />
                                <br/>
                            </li>
                            <li>
                                <p>
                                    Now we have a request C of size 7.
                                </p>
                                <img src="img/data_structure_21.png" alt="" />
                                <br/>
                                <img src="img/data_structure_22.png" alt="" />
                                <br/>
                                <img src="img/data_structure_23.png" alt="" />
                                <br/>
                            </li>
                            <li>
                                <p>
                                    Now, C releases its memory.
                                </p>
                                <img src="img/data_structure_24.png" alt="" />
                                <br/>
                                <img src="img/data_structure_25.png" alt="" />
                                <br/>
                                <img src="img/data_structure_26.png" alt="" />
                                <br/>
                            </li>
                        </ol>
                    </article>
                </div>
            </section>
        </div>
    </div>
</html>
