<!Doctype html>
<html lang="en">
    <head>
        <title>XSM Execution Environment</title>
        <meta charset="UTF-8">
        <!--<link rel="stylesheet" href="css/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/style_new.css">
        <script src="js/jquery-1.12.1.min.js" charset="utf-8"></script>
        <link rel="stylesheet" href="js/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4.css"><div id="gist28627206" class="gist">
        <link rel="stylesheet" href="js/embed-cbe5b40fa72b0964f90d4919c2da8f8f94d7c9f6c2aa49c07f6fa3.css"><div id="gist28627206" class="gist">
    </head>
    <div class="container">
        <header id="navtop">
            <a href="index.html" class="logo fleft"><img src="img/logo.png" alt=""></a>
            <nav class="fright">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
                        <li><a href="#">Help</a></li>
                        <li><a href="#">Code</a></li>
                        <li><a href="roadmap.html">Roadmap</a></li>
                        <li><a href="documentation.html" class="navactive">Documentation</a></li>
                </ul>
            </nav>
        </header>
        <div class="Services-page main grid-wrap">
            <header class="grid col-full">
                <hr/>
                <p class="fleft">XSM Execution Environment Tutorial</p>
                <br>
                <br>
                <!-- <a class="button" href="">Download as PDF</a> -->
            </header>
            <aside class="grid col-one-quarter mq2-col-full">
                <menu>
                    <ul>
                        <li class="sec"><a href="#nav-pre-requisites">Pre-Requisites</a> </li>
                        <li class="sec"><a href="#nav-experiment1">Experiment I</a></li>
                        <li class="sec"><a href="#nav-experiment2">Experiment II</a></li>
                        <li class="sec"><a href="#nav-experiment3">Experiment III</a></li>
                    </ul>
                </menu>
            </aside>
            <body>
            <section class="grid col-three-quarters mq2-col-full">
                <div class="grid-wrap" id="nav-pre-requisites">
                    <article class="grid col-full">
	                    <p>                    	
							A Tutorial on program execution.<br>
							<b>Pre-requisite reading:</b>
							<ul>
								<li id="otis">1.  A rigorous reading of <a href="abi.html#nav-virtual-address-space-model" target="_blank">XSM virtual machine model</a>.</li>
								<li id="otis">2.  A quick reading of  the ExpOS <a href="abi.html" target="_blank">ABI documentation</a> for XSM machine.</li>
							</ul>
						</p>
						<p>
							<b>Learning Objectives </b>:
							<ul>
								<li id="otis">At the end of this tutorial you will be able to generate XEXE executable files containing XSM assembly language programs which can be run on the XSM simulator given to you. Along the way, you will learn how to use the system call and library interface of the underlying Operating system to handle console input and output.</li>
							</ul>
						</p>
						<hr>
					</article>
                    <article class="grid col-full">
                    <p>
                    	This tutorial helps you to gain a basic understanding of the execution environment provided by the XSM simulator. The compiler you design for the ExpL language is supposed to generate target XSM machine code that runs on the XSM Simulator provided to you. However, the bare machine cannot directly run the target code. The operating system (OS)  that runs on top of the machine is the actual software that sets up an execution enviornment necessary for running the target code. Hence, the compiler's obligation is to generate target code that is understandable to the operating system.
                    </p>
                    <p>
                    	Consequently, there must be a document provided by the OS implementation to the compiler designer that explains the interface to the operating system that the compiler must adhere to. This document is called the <b>Application Binary Interface</b> or <b>ABI</b>.
                    </p>
                    <p>
                     	The XSM simulator given to you is actually much more than a bare XSM hardware simulator. It has the capacity to understand the ABI for the ExpOS operating System for the XSM machine. This ABI expects that the compiler generates the target file in a format called the <a href="abi.html#nav-XEXE-executable-file-format" target="_blank">XEXE executable format</a>.
                    </p>
  					<p>
  						Your compiler simply needs to generate an executable file following the XEXE executable format and store it on the local machine. When you use the XSM simulator to run the program, the following actions take place.<br>
  						<ul>
  							<li id="otis">1. The script that runs the simulator transfers the file from your local machine's disk to the XSM machine's (simulated) hard disk.</li>
  							<li id="otis">2. It then boots up the operating system (the OS is already preloaded in the simulator's hard disk). The bootstrap loader starts in the kernel mode and sets up a user process in memory, allocating an address space.  Then, it transfers the execute file from the hard disk to the <a href="abi.html#nav-virtual-address-space-model" target="_blank"> code region</a> of this memory. Page tables are also set up to run the process in user mode[LINK].</li>
  							<li id="otis">3. Finally, the simulator sets the instruction pointer (IP) to the address specified in the entry-point field of the header of the executable file and control transfers to this instruction, resulting in execution of the loaded program starting with the instruction specified by the entry point. The machine also switches from the kernel mode to the user mode. (Technically, the OS code pushes the entry point address on to the program's stack and executes the IRET instruction[LINK] resulting in transfer of control in user mode to the 	specified memory address. These details are not relevant for your work and are noted just for the sake of information.)</li>
  						</ul>
  					</p>
  					<p>
  						We start now by generating a small XEXE executable file containing an XSM program to find the sum of two numbers and store the value in a register. The value of the register will have to be inspected in order to view the ouput. This is possible by executing the XSM simulator in <a href="xsmusagespec.html#nav-debug" target="_blank">debug mode</a>. Later we will see how console input and output are handled.
  					</p>
  					<hr>
  				</article>
                <article class="grid col-full">
	                <p id="nav-experiment1">
	                	<b>Experiment I</b> : Using Registers.<br>
	                </p>
	                <p>
	                	<b>Excercise 1</b> : Adding two numbers.
	                </p>
	                <p>
	                	As noted above, executable programs must be designed in such a way that it must be possible for the file to be loaded and executed by the underlying operating system. When a program is loaded into memory for execution by the OS, the OS typically assigns a virtual address space (or simply an address space). In the present case, the address space of a program starts at address 0 of the memory and ends at address 5119. This means that while designing the target program, you may assume that this is the total computer memory accessible to the program when it executes.
	                </p>
	                <p>
	                	The compiler typically divides this memory into various regions – namely the code region, (often called the text region), data region, stack region, heap region etc. The ABI specifies the starting address and ending address of each region in the address space. This is specified <a href="abi.html#nav-virtual-address-space-model" target="_blank">HERE</a>. The ABI specifies that  the compiler must divide the memory into four regions – <b>library, code, stack and heap</b>. (there is <b>no separate data region</b> – instead the stack region must be used for this as well).
	                </p>
   					<p>
   						For our immediete reqruiements, the important region is the code region. The code region contains two parts – a <b>header</b> (addresses 2048 to 2055) and <b>code</b> (address 2056-4095). The target code will be loaded into this region of the memory when the OS (simulator) loads the program for execution. Details will be described soon.
   					</p>
   					<p>
   						The XEXE executable format stipulates that the first 8 words of an executable file must be a header. The rest of the file must contain assembly language program to be executed. The loader actually will simply copy the contents of the executable file into the region of memory between addresses 2048 and 4095. Consequently, the header will be loaded between 2048-2055 and the rest of the file (containing the XSM instructions) into addresses 2056 to 4095. The contents of the file will be copied to the memory in the order in which they appear in the file.
   					</p>
   					<p>
   						Since each XSM assembly instruction requires two words of memory storage, the first instruction will be loaded into address 2056 and 2057, the second in 2058 and 2059 and so forth.  Since the code region of the memory ends at 4095, the maximum number of instructions possible in a program is limited to 1020. This is the limit set by the particular OS platform used in this experiment. 
   					</p>
   					<p>
   						One important field of the header is its second entry – the entry point. The loader initializes the <b>Instruction Pointer (IP)</b> register of the XSM machine to this value. Thus, if entry point is 2064, the simulator the XSM machine simulator will start program execution by fetching the instruction stored at this address. The ABI stipulates that the value of the first field called the <b>magic number</b> must be set to zero. The setting of other fields in the header are not relevant for this experiment.
   					</p>
    				<p>
    					<b>Note</b>:  When the program is actually loaded for execution by the OS, the physical addresses in the actual memory to which the executable program is loaded will be different from the virtual addresses set by the compiler. Such relocation requires architecture support. In the XSM machine, the support is through paging. However address translation is a concern of the OS, not of the compiler. Hence we will not pursue this matter here. However, for those interested, details on XSM paging scheme is given HERE[LINK].
    				</p>
  					<p>
  						With this, we complete the background needed to complete the present experiment.  We now proceed to the implementation.
  					</p>
  					<p>
  						<b>Implementation</b> :<br><br>
						An XSM assembly language program to find the sum of two numbers could work as the following:<br>
						<div class="syntax">
							1.  Store the first number in a register – say R0.<br>
							2.  Store the second number  in a register – say R1.<br>
							3.  ADD R0, R1.<br>
						</div>
  					</p>
  					<p>
  						The result will be stored in R0.<br>
  						To generate code for the above tasks and write it into a target_file, you must write code as:<br>
  						<div class="syntax">
  							fprintf(target_file, "MOV R0, 3\n");<br>
							fprintf(target_file, "MOV R1, 2\n");<br>
							fprintf(target_file, "ADD R0, R1\n");<br>
							fprintf(target_file, "BRKP");
  						</div>
  					</p>
  					<p >
  						The target_file will look as shown below.
	  					<script src="js/edda61e70ba922a59f37b9680c420b53.js"></script>
  					</p>
					<p>
						However, the header must be written into the first eight words of the target file before writing out the instructions. You must reserve the first eight words of the executable file for the header before writing code into the file. Now, set the entry point field to the first instruction to be executed. If the code is written immedietely after the header, the first instruction will be loaded to memory address 2056 and 2057 (see <a href="abi.html#nav-virtual-address-space-model" target="_blank">memory model</a>). Hence, you must set the header as:<br>
						<div class="syntax"> fprintf(target_file, " %d\n %d\n %d\n %d\n %d\n %d\n %d\n %d\n ",0,2056,256,0,0,0,0,0); </div> 
					</p>
					<p>
						<script src="js/a244076527f1f9daae58794006b3461a.js"></script>
					</p>
					<p>
						The above code essentially sets the first field – magic number - to  0, the second field - entry point - to 2056, the third field – text size to 256 and other fields to 0. The text size fields tell the OS that only one memory page need be allocated for storing the code. (The present program requires just 14 memory words <b>[Why?]</b> – but still the minimum allocation possible is one page = 512 words).
					</p>
					<p>
						Now, to run the executable file, you must use the XSM simulator. The simulator usage commands are specified <a href="xsmusagespec.html" target="_blank">here</a>. You must read the above link before proceeding further.
					</p>
					<p>
						The simulator expects a library file by the name library.lib together with the XEXE executable file to be supplied as a command line argument. You will learn more about the library in later stages. For now create a file library.lib with just on instruction in the XSM simulator folder.
						<script src="js/2b86865baf9befd7ff0e87fb5fa7ba8b.js"></script>
					</p>
					<p>
						Now we will try to execute the target_file in the <a href="xsmusagespec.html" target="_blank">debug mode</a>.
						<ul>
							<li id="otis">1. Open terminal and navigate to the simulator folder.</li>
							<li id="otis">2. Type "./xsm -l library.lib -e < path to target_file.xsm > --debug".</li>
						</ul>
					</p>
					<p>
						Since we are trying to execute the target_file in debug mode, the simulator executes all the instructions present before the BRKP instruction. We can check the contents of the registers at this point.
						<ul>
							<li id="otis">Type <b>reg R1</b>.</li>
							<p style="color: red;"> pic here</p>
						</ul>
						We can see that value 2 is stored in this register. Now try typing "reg R0".
						<p style="color: red;"> pic here</p>
						We can see that value stored in the register is 5.<b>[Why?]</b><br>
						Now type <b>reg R0 R1</b>
						<p style="color: red;">PIC HERE</p> 
						The command "reg Rn Rm" dislays the contents of all registers from n to m.
						Now type <b>reg</b>
						<p style="color: red;">PIC HERE</p> 
						This command displays the contents of all the machine registers namely IP, SP, BP, PTBR, PTLR, EIP, EC, EPN, EMA, R0-R19 in that order.
					</p>

<!-- /*  Give usage instructions here – run the simulator in debug mode and  watch the contents of register R0 – spoon feed   - complete this part */  <br><br> -->
					<p>
						<b>Note</b>: You would have observed that if you try to continue to execute beyond the last instruction, the simulator flags abnormal program termination. This is because after executing the last instruction of the program, the simulator increments the instruction pointer and tries to execute the next instruction. However, since there is no valid instruction stored in the memory, the simulator will enconter an invalid instruction and generate an exception. This results in transfer of program control to the OS kernel code that will terminate execution and report error. We will see how graceful program termination is achieved in the next experiment.  
					</p>
					<p>
						<b>Exercise 2 </b>:  Write an XSM assembly langauge program to find the largerst of three numbers and run it on the simulator. You will learn how to handle the JMP instruction while doing this exercise.
					</p>
  					<p>
  						<b>Exercise 3 </b>:  Modify your code generation module to store the result of the previous program in the first location in <a href="abi.html#nav-virtual-address-space-model" target="_blank">stack region</a> namely address 4096 and watch the contents in debug mode after execution.
  					</p>
  					<hr>
  				</article>
  				<article class="grid col-full">
	                <p id="nav-experiment2"> <b>Experiment II</b> : Input/Output using OS system call interface</p>
	                <p>
						<b>Reading Assignment</b>: Read the low level system call interface of the <a href="abi.html#nav-lowlevel-syscall-interface" target="_blank">ABI</a>  
	                </p>
	                <p>
						In this experiment, you will extend the previous stage to print the result of adding two numbers to the console using a low system call interface provided by the ABI.    
	                </p>
	                <p>
						The conceptual point to understand here is that console I/O is handled by the kernel routines operating system.   Kernel modules execute in previliged mode of execution and can execute special previliged instructions that access devices and other resources in a machine.  
	                </p>
	                <p>
						However, your XEXE executable program execute in unpreviliged mode. Such programs are called <b>application programs</b> or simply applications. These programs cannot contain previliged instructions. (If you try to write previliged instruction in your program and execute, the machine will raise an exception when it fetches the instruction and the exception handler module of the OS kernel will terminate the application, flagging an error.) The <a href="abi.html#nav-XSM-instruction-set"  target="_blank">instructions</a> specified in the ABI given to you are all unpreviliged instructions. (To know more about previliged instructions in XSM, see <a href="http://exposnitc.github.io/arch_spec-files/instruction_set.html#privileged_instruction" target="_blank"> ExPOS documentation</a>).  
					</p>
					<p>
						An OS typically provides you with a set of kernel level routines called system calls which your code can invoke for performing console I/O. A system call is invoked by a trap instruction (The INT instruction is the trap instruction of the XSM machine) specifying the system call number specifying the particular OS service (like read/write/program exit) required. (see details <a href="abi.html#syscalltable" target="_blank">here</a>). The OS also specifies how an application must pass arguments and extract return values from system calls called the calling conventions. Generally, arguments to a system call are passed through the application program's stack. These details are written down in the  <a href="abi.html#nav-lowlevel-syscall-interface" target="_blank">low level system call interface</a> of the ABI.   
  					</p>
  					<p>
						<b>Note</b>:  An OS typically will provide a large number of system call for various requirements. For our purposes, the relevant system calls are those for console read, console write and program exit.
					</p>
					<p>
						As noted previously, the arguments/return values to/from a system call are passed through a program stack. Each application maintains a stack region in memory where run-time data can be stored while the program executes. The ABI specification stipulates that the stack region of a program shall be between memory addresses 4096 and 5119. The application generally reserves some initial addresses starting from 4096 for storing global variables in the program (called <b>static allocation</b>) and then initializes the stack to the first free memory after those allocated to variables. Arguments to a system call are pushed into the stack before executing the INT instruction. Before the system call transfer control back (using the IRET instruction – see [LINK]), return values would have been pushed into the stack.
					</p>
					<p>
						<b>Implementation</b> :<br><br>

						In Exercise 3 of Eperiment I, you are asked to store the sum of two numbers into memory address 4096. Now, we will see how this number can be printed out into the console.
					</p>
					<p>
						To print the contents of memory location 4096  into the console, we need to:
						<ul>
							<li id="otis">1. Push the address 4096 into the stack along with other arguments to the system call.</li>
							<li id="otis">2. Invoke the write system call using the INT instruction specifying the appropriate interrupt number.</li>
						</ul>
					</p>
					<p>
						The following example shows sample code that must be added to your earlier program to output the contents of the location 4096.
					</p>

					<p>
 						Store the value of the R0 in the memory location 4096.
 						<div class="syntax">MOV [4096], R0</div>
 					</p>
 					<p>
						The XSM machine increments SP immedietely before a PUSH operation by XSM machine and hence the first PUSH operation will be storing data to address 4097 (and hence will not destroy the data in address 4096).  
 						<div class="syntax">MOV SP, 4096</div>
 					</p>
 					<p>
						Now, the arguments to a write operation must be pushed on to the stack:  
 						<b>System Call Number</b> : 5 for Write
 						<div class="syntax">
	 						MOV R2, 5<br>
	 						PUSH R2
 						</div>
 					</p>
 					<p>
 						<b>Argument 1</b> :  value -2
 						<div class="syntax">
	 						MOV R2, -2<br>
	 						PUSH R2
	 					</div>
	 				</p>
 					<p>
 						<b>Argument 2</b> : Address of the memory word to be pushed  -  Here value is 4096. 
 						<div class="syntax">
	 						MOV R2, 4096
	 						PUSH R2
 						</div>
 					</p>
 					<p>
 						<b>Argument 3</b> : Blank /* Push any register */
 						<div class="syntax">
 							PUSH R2
 						</div>
 					</p>
 					 <p>
 						<b>Storage for Return Value</b> :  Push any register
 						<div class="syntax">
 							PUSH R2
 						</div>
 					</p>
 					<p>
						Now, invoke the trap instruction to invoke the kernel module for console output. The ABI specifies that the interrupt number must be 7.<br><br>
 						<b>Interrupt Number</b> :  7 for Write System Call
 						<div class="syntax">
 							INT 7
						</div>
					</p>
						  
					<p style="color: red;">
						Add figure to show the state of the stack.  
					</p>
					<p>
						The above sequence of instructions will invoke the write system call. Upon successful write operation, the value 0 will be returned to the calling program through the stack. We assume here that the call will be successful.
					</p>
					<p>					
						Now upon exit from the system call :
						<ul>
							<li id="otis">1. The return value may be retrievied if required.</li>
							<li id="otis">2. The stack must be set back to the state before the call as stipulated in the ABI.  This is necessary to avoid loss of stack space after each call.</li>
						</ul>
					</p>
					<p>
						The following instructions will do the above.  
						<div class="syntax">
						//  The following code must be executed after return from the system call<br>
						POP R0 // Pop and save the return value in some register<br>
						POP R1 // Pop and discard the argument3<br>
						POP R1 // Pop and discard the argument2<br>
						POP R1 // Pop and discard the argument1<br>
						POP R1 // Pop out all – stack must come back to state before the call.<br>
						</div>
					</p>
					<p>
						The target_file will look as shown below after adding the Write system call.
						<script src="js/49fce38a3c5dfa5419e73ec172a770be.js"></script>
					</p>
					<p>
						Now, having generated the executable program run the program using the simulator. To run the program, follow the 
						instructions given below.

						<ul>
							<li id="otis">1. open terminal and navigate to the XSM simulator folder.</li>
							<li id="otis">2. Type "./xsm -e < path to target_file.xsm> "</li>
						</ul>
					</p>
					<p style="color: red;">
						You can see that the value 5 is printed on the console along with the error.
						Show output.  There will be an exception error because exit was done SHOW THE OUTPUT HERE.
						/*        upto this   */

					</p>
					<p>
						Observe that the simulator flagged an error after the last statement was executed. This happened because after executing the last valid instruction in the program, the simulator had no idea that the program had ended and hence tried to fetch from memory the next instruction. However, since there is no valid insturction in that memory location, the machine raises an exception [see LINK for exceptions of XSM] and control was transfered to an exception handler routine of the OS kernel. Typically, in a multitasking environment, the OS will terminate the program, reclaim resources allocated to it an schedule some other process.
					</p>
					<p>   
						The exception handler routine of the XSM simulator given to you is designed to print an error message and terminate the simulation.
					</p>
					<p>
						The "proper" way to exit the application is to invoke the exit system call. This will inform the OS that the program has finished execution. The exit system call code of a typical OS kernel will "gracefully" exit the application and schedule other programs for execution. The OS will never return to the application that invokes the exit system call.
					</p>
					<p>
						The exit system call routine of the XSM simulator given to you will print a message indicating successful program execution and terminate the simulation.  
					</p>
					<p>
						<b>Exercise 4</b> : Follow the instructions in the low level system call interface of the ABI to invoke the exit system call after the console output in your previous program.  
					</p>
					<p>
						<b>Exercise 5</b> : Write an XSM assembly language program to read three numbers from the console and print the largest. (Invoke the read system call for console input.)
					</p>
					<p>
						<b>Exercise 6</b> : Write an XSM assembly language program to read numbers until a zero is entered and print their sum.
					</p>
					<p>
						<b>Important Note</b> :  Exercises 5 and 6 essentially ask you to handle conditional and iterative constructs in assembly language. These exercises give insight into how machine code must be genrated for <b>if-then-else and while-do</b> constructs of programming languages.     
					</p>
					<hr>
				</article>
				<article class="grid col-full">
	                <p id="nav-experiment3">
						<b>Experiment III</b> : Understanding the Library Interface
					</p>
					<p>
						<b>Prerequisite Reading</b> : Read and understand the <a href="abi.html#nav-eXpOS-system-library-interface" target="_blank">library interface</a>.
					</p>
					<p>
						In this experiment, you will learn how to implement the library interface stipulated in the ABI for supporting read, write and exit system calls.  
					</p>
					<p>
						The  <a href="abi.html#nav-virtual-address-space-model" target="_blank">memory address space model</a> of a program reserves the first 1024 words of the address space of a program to load a library. Here we explain the purpose of the library.
					</p>
					<p>
						If we consider C programs, almost every program uses the routines in the library stdio.h. Since in a computer system, several application programs will be running concurrently, it is a good idea to have the code for stdio.h loaded once at bootstrap time into some region of the physical memory and link this memory to the address space of each program's standard library region at load time. This code will be designed once and shared between all applications.  
					</p>
					<p>
						The ABI specifies that the ExpOS library for XSM machine must be linked to address 0 to 1024. The XSM simulator given to you will load the contents of the file library.lib to the addresses 0 - 1024 of your program. The ABI stipulates that the library must support functions for read, write and exit. (The library also must contain functions Alloc, Free and Initialize which will not be discussed here.)
					</p>
					<p>
						To access any library function, an application must transfer control to the code at memory address 0 using the instruction <b>CALL</b>. This is the first memory address in the library region. The arguments to the call specify which library function is being invoked. The library interface is specified <a href="abi.html#nav-eXpOS-system-library-interface" target="_blank">here</a>.    
					</p>
					<p>
						An application program can execute read, write and exit functions through the library. This means that once the library is implemented, application programs can invoke call the library to perform read, write and exit operations by passing appropriate function identifying code and arguments. Internally, the library contains code that  calls the system call.  
					</p>
					<p>
						One might naturally raise the question – why should we route the system calls through the library than call them directly as was done so far. There are several advantages in using the library. At a later time, if the interrupt number for an OS service – say write – gets modified, only the library needs to be replaced. The compiler need not be modified, nor application programs need re-compilation. Thus, the library provides an abstraction that hides low level details from the compiler and the application.
					</p>
					<p>
						<b>Implementation</b> :<br><br>	
							In this experiment, we implement the program of Experiment II using the library.  
					</p>
					<p style="color: red;">
						/*  Complete this stage in the same lines at Experiment I and Experiment II */  
					</p>
					<p>
						<b>Exercise 7</b> : Implement read() and exit() functions of the library.  
					</p>
					<p>
						<b>Exercise 8</b> : Modify the program to read three numbers from the console and print the largest to perform I/O using the library interface.   
					</p>
					<p>
						<b>Exercise 9</b> : Modify language program to read numbers until a zero is entered from the console and print their sum to perform I/O using the library interface.  
					</p>
				</article>